<html>
	<head>
		<title>Cube Earth</title>
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
		<script src="../js/jquery.js" type="text/javascript"></script>
		<script src="../js/copperlicht.js" type="text/javascript"></script>
		<style type="text/css">
			body
			{
				margin: 0;
				background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#aaa));
			}

			#cube-earth
			{
				position: absolute;
				left: 10%;
				top: 10%;
				width: 80%;
				height: 80%;
			}
		</style>
		<script id="vs-simplecolor" type="x-shader/x-vertex">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform mat4	worldviewproj;
			attribute vec4	vPosition;

			void main()
			{
				gl_Position = worldviewproj * vPosition;
			}
		</script>
		<script id="fs-simplecolor" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform vec4 vColor;

			void main()
			{
				gl_FragColor = vColor;
			}
		</script>
		<script type="text/javascript">
			CL3D.MeshBuffer.prototype.setVIMesh = function(mesh) {
				if (this.Vertices != mesh.vertices || this.Indices != mesh.indices) {
					this.Vertices = mesh.vertices;
					this.Indices = mesh.indices;
					this.update();
				}
			};

			CL3D.Renderer.prototype.MaterialUniforms = {};

			CL3D.Renderer.prototype.createMaterialTypeEx = function(vs, fs, uniforms, blendenabled, blendsfactor, blenddfactor) {
				var type = this.createMaterialType(vs, fs, blendenabled, blendsfactor, blenddfactor);

				this.MaterialUniforms[type] = uniforms;

				return type;
			};

			CL3D.Renderer.prototype.OnChangeMaterial = function(mattype) {
				var uniforms = this.MaterialUniforms[mattype];
				if (uniforms) {
					var gl = this.getWebGL();
					var program = this.getGLProgramFromMaterialType(mattype);
					$.each(uniforms, function(key, uniform) {
						var location = gl.getUniformLocation(program, key);

						while (typeof (uniform) == "function")
							uniform = uniform();

						if (typeof (uniform) == "number")
							gl.uniform1f(location, uniform);
						else
							switch (uniform.length) {
							case 1:
								gl.uniform1f(location, uniform[0]);
								break;
							case 2:
								gl.uniform2f(location, uniform[0], uniform[1]);
								break;
							case 3:
								gl.uniform3f(location, uniform[0], uniform[1], uniform[2]);
								break;
							case 4:
								gl.uniform4f(location, uniform[0], uniform[1], uniform[2], uniform[3]);
								break;
							default:
								throw "invalid uniform length: " + uniform.length;
							}
					});
				}
			};
		</script>
		<script type="text/javascript">
			var CL, Scene;

			var util = {
				createVertex: function(pos, normal, tu, tv) {
					var v = new CL3D.Vertex3D(true);
					v.Pos = pos;
					if (normal)
						v.Normal = normal;
					if (tu || tu == 0)
						v.TCoords.X = tu;
					if (tv || tv == 0)
						v.TCoords.Y = tv;

					return v;
				},
				createSimpleCubeMesh: function(length) {
					length = length || 1;
					var half = length / 2;

					var vertices = [
						util.createVertex(new CL3D.Vect3d(-half, -half, -half)),
						util.createVertex(new CL3D.Vect3d(-half, -half, +half)),
						util.createVertex(new CL3D.Vect3d(-half, +half, -half)),
						util.createVertex(new CL3D.Vect3d(-half, +half, +half)),

						util.createVertex(new CL3D.Vect3d(+half, -half, -half)),
						util.createVertex(new CL3D.Vect3d(+half, -half, +half)),
						util.createVertex(new CL3D.Vect3d(+half, +half, -half)),
						util.createVertex(new CL3D.Vect3d(+half, +half, +half))
					];
					var indices = [
						0, 1, 2, 1, 3, 2,
						4, 6, 5, 5, 6, 7,
						1, 5, 3, 5, 7, 3,
						0, 2, 4, 2, 6, 4,
						2, 3, 7, 7, 6, 2,
						5, 1, 0, 0, 4, 5
					];

					return { vertices: vertices, indices: indices };
				},
				createCubeArrayMeshes: function(options) {
					options = options || {};
					options.Segments = options.Segments || 10;
					options.Spheral = options.Spheral || 0.54;

					var grids = options.Segments * 1.5 + 1;
					var inv_grids = 1 / grids;

					var eachRange2D = function(ul, uh, vl, vh, elem) {
						for (var u = ul; u <= uh; ++u)
							for (var v = vl; v <= vh; ++v)
							elem(u, v);
					};

					var faceVerticesCount = (options.Segments + 1) * (options.Segments + 1);

					var getVertexIndex = function(f, u, v) {
						return faceVerticesCount * f + u * (options.Segments + 1) + v;
					};

					var indices = [];
					for (var f = 0; f < 6; ++f) {
						eachRange2D(0, options.Segments - 1, 0, options.Segments - 1, function(u, v) {
							indices.push(getVertexIndex(f, u, v));
							indices.push(getVertexIndex(f, u + 1, v + 1));
							indices.push(getVertexIndex(f, u + 1, v));

							indices.push(getVertexIndex(f, u, v));
							indices.push(getVertexIndex(f, u, v + 1));
							indices.push(getVertexIndex(f, u + 1, v + 1));
						});
					}

					var mendIndicesMap = {};
					var mendIndicesInitialized = false;

					var units = [];

					// traverse all units
					for (var ax = -1; ax <= 1; ++ax)
						for (var ay = -1; ay <= 1; ++ay)
							for (var az = -1; az <= 1; ++az) {
								var vertices = [];

								var xl = ax * (options.Segments + 1) - options.Segments / 2, xh = ax * (options.Segments + 1) + options.Segments / 2;
								var yl = ay * (options.Segments + 1) - options.Segments / 2, yh = ay * (options.Segments + 1) + options.Segments / 2;
								var zl = az * (options.Segments + 1) - options.Segments / 2, zh = az * (options.Segments + 1) + options.Segments / 2;

								eachRange2D(yl, yh, zl, zh, function(y, z) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(xl, y, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(zl, zh, yl, yh, function(z, y) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(xh, y, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(zl, zh, xl, xh, function(z, x) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, yl, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(xl, xh, zl, zh, function(x, z) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, yh, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(xl, xh, yl, yh, function(x, y) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, y, zl).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(yl, yh, xl, xh, function(y, x) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, y, zh).multiplyWithScal(inv_grids), options.Spheral))); });

								var mended = 0;

								for (var f = 0; f < 6; ++f) {
									eachRange2D(0, options.Segments, 0, options.Segments, function(u, v) {
										var vertex = vertices[getVertexIndex(f, u, v)];

										// compute normal
										{
											var pos = vertex.Pos;
											var normals = [];
											var L, R, U, D;

											L = (u > 0) && (vertices[getVertexIndex(f, u - 1, v)].Pos.substract(pos));
											R = (u < options.Segments) && (vertices[getVertexIndex(f, u + 1, v)].Pos.substract(pos));
											U = (v > 0) && (vertices[getVertexIndex(f, u, v - 1)].Pos.substract(pos));
											D = (v < options.Segments) && (vertices[getVertexIndex(f, u, v + 1)].Pos.substract(pos));

											if (L && U)
												normals.push(L.crossProduct(U).getNormalized());
											if (L && D)
												normals.push(D.crossProduct(L).getNormalized());
											if (R && U)
												normals.push(U.crossProduct(R).getNormalized());
											if (R && D)
												normals.push(R.crossProduct(D).getNormalized());

											vertex.Normal = new CL3D.Vect3d(0, 0, 0);
											$.each(normals, function(i, n) {
												vertex.Normal.addToThis(n);
											});
											vertex.Normal.multiplyWithScal(1 / normals.length);
											vertex.Normal.normalize();
										}

										var wuv = util.xyzToWuv(pos);
										vertex.TCoords.X = wuv.U;
										vertex.TCoords.Y = wuv.V;

										// append a mend vertex
										if (pos.Z == 0) {
											++mended;

											if (!mendIndicesInitialized)
												mendIndicesMap[getVertexIndex(f, u, v)] = vertices.length;

											var newVertex = vertex;
											if (vertex.TCoords.X == 0) {
												newVertex = new CL3D.Vertex3D(true);
												newVertex.Pos = vertex.Pos;
												newVertex.Normal = vertex.Normal;
												newVertex.TCoords.Y = vertex.TCoords.Y;
												newVertex.TCoords.X = 1;
											}

											vertices.push(newVertex);
										}
									});
								}

								units.push({ vertices: vertices, indices: indices, mended: mended });

								mendIndicesInitialized = mendIndicesInitialized || mended;
							}

					// build mendIndices
					var mendIndices = [];
					for (var f = 0; f < 6; ++f) {
						eachRange2D(0, options.Segments - 1, 0, options.Segments - 1, function(u, v) {
							var i00 = getVertexIndex(f, u, v);
							var i10 = getVertexIndex(f, u + 1, v);
							var i01 = getVertexIndex(f, u, v + 1);
							var i11 = getVertexIndex(f, u + 1, v + 1);

							switch(f) {
								case 0:
								case 3:
									i01 = mendIndicesMap[i01] || i01;
									i11 = mendIndicesMap[i11] || i11;

									break;
								case 1:
								case 2:
									i10 = mendIndicesMap[i10] || i10;
									i11 = mendIndicesMap[i11] || i11;

									break;
							}

							mendIndices.push(i00);
							mendIndices.push(i11);
							mendIndices.push(i10);

							mendIndices.push(i00);
							mendIndices.push(i01);
							mendIndices.push(i11);
						});
					}

					$.each(units, function(i, unit){
						if(unit.mended)
							unit.indices = mendIndices;
					});

					return units;
				},
				spherize: function(v, k) {
					var m = v.getLength();
					var r = Math.max(Math.abs(v.X), Math.max(Math.abs(v.Y), Math.abs(v.Z)));
					var radius = m * k + r * (1 - k);

					return new CL3D.Vect3d(v.X * radius / m, v.Y * radius / m, v.Z * radius / m);
				},
				xyzToWuv: function(v) {
					var m = v.getLength();
					var r = Math.sqrt(v.X * v.X + v.Z * v.Z);

					var V = Math.acos(v.Y / m) / Math.PI;
					var U = r == 0 ? 0 : Math.acos(v.X / r) / (Math.PI * 2);
					if (v.Z < 0)
						U = 1 - U;

					return {W: m, U: U, V: V};
				}
			};
			util.SimpleCubeMesh = util.createSimpleCubeMesh(1);
			util.CubeArrayMeshes = util.createCubeArrayMeshes();

			$(function() {
				var canvas = $("#cube-earth");
				canvas.attr("width", canvas.width());
				canvas.attr("height", canvas.height());

				CL = new CL3D.CopperLicht("cube-earth", null, 30);
				if (CL.initRenderer({ antialias: true })) {
					Scene = new CL3D.Scene();
					CL.addScene(Scene);

					Scene.setBackgroundColor(0x00000000);

					var cam = new CL3D.CameraSceneNode();
					cam.Pos = new CL3D.Vect3d(0, 0, 1);
					cam.setTarget(new CL3D.Vect3d(0, 0, 0));
					cam.setFov(Math.PI * 0.3);
					var animator = new CL3D.AnimatorCameraModelViewer(cam, CL, [0]);
					cam.addAnimator(animator);
					animator.Radius = 4;
					Scene.getRootSceneNode().addChild(cam);
					Scene.setActiveCamera(cam);
					cam.setAspectRatio(canvas.width() / canvas.height());

					var cube = new CL3D.SceneNode();
					Scene.getRootSceneNode().addChild(cube);

					var cubeMat = CL.getRenderer().createMaterialTypeEx($("#vs-simplecolor").text(), $("#fs-simplecolor").text(), { vColor: [0, 0.2, 0.4, 1] });

					$.each(util.CubeArrayMeshes, function(i, unit) {
						var buffer = new CL3D.MeshBuffer();
						buffer.setVIMesh(unit);
						//buffer.Mat.Type = cubeMat;
						buffer.Mat.Type = CL3D.Material.EMT_SOLID;
						buffer.Mat.Tex1 = CL.getTextureManager().getTexture("../res/images/Earth.JPG", true);

						var mesh = new CL3D.Mesh();
						mesh.AddMeshBuffer(buffer);

						var node = new CL3D.MeshSceneNode();
						node.setMesh(mesh);
						cube.addChild(node);
					});
				}
			});
		</script>
	</head>
	<body>
		<canvas id="cube-earth"></canvas>
	</body>
</html>
