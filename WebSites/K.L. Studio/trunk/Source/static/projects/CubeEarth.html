<html>
	<head>
		<title>Cube Earth</title>
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
		<script src="../js/jquery.js" type="text/javascript"></script>
		<script src="../js/copperlicht.js" type="text/javascript"></script>
		<style type="text/css">
			body
			{
				margin: 0;
				background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#aaa));
				background: -moz-linear-gradient(#fff, #aaa);
			}

			#cube-earth
			{
				position: absolute;
				left: 10%;
				top: 10%;
				width: 80%;
				height: 80%;
			}
		</style>
		<script id="vs-simplecolor" type="x-shader/x-vertex">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform mat4	worldviewproj;
			attribute vec4	vPosition;

			void main()
			{
				gl_Position = worldviewproj * vPosition;
			}
		</script>
		<script id="fs-simplecolor" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform vec4 vColor;

			void main()
			{
				gl_FragColor = vColor;
			}
		</script>
		<script id="vs-3dposition" type="x-shader/x-vertex">
			#ifdef GL_ES
			precision highp float;
			#endif


			uniform mat4	worldviewproj;
			uniform mat4	normaltransform;
			uniform mat4	modelviewtransform;

			attribute vec4	vPosition;
			attribute vec4	vNormal;
			attribute vec4	vTexCoord1;
			attribute vec4	vTexCoord2;

			varying vec3	v_Position;
			varying vec3	v_Normal;
			varying vec2	v_TexCoord1;
			varying vec2	v_TexCoord2;


			void main()
			{
				gl_Position = worldviewproj * vPosition;

				v_Position = (modelviewtransform * vPosition).xyz;
				v_Normal = normalize((normaltransform * vNormal).xyz);
				v_TexCoord1 = vTexCoord1.st;
				v_TexCoord2 = vTexCoord2.st;
			}
		</script>
		<script id="fs-directionallight" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif


			uniform mat4		normaltransform;
			uniform sampler2D	texture1;

			uniform vec3	vLightAmbientColor;
			uniform vec3	vLightDirection;
			uniform vec3	vLightDirectionalColor;
			uniform vec3	vMaterialEmissive;
			uniform vec3	vMaterialSpecular;
			uniform float	vMaterialShiness;

			varying vec3	v_Normal;
			varying vec2	v_TexCoord1;


			void main()
			{
				vec4 color;

				vec3 L = -normalize((normaltransform * vec4(vLightDirection, 1)).xyz);

				vec4 tex = texture2D(texture1, v_TexCoord1);

				vec3 ambient = tex.rgb * vLightAmbientColor;

				float diffuseLight = max(dot(v_Normal, L), 0.);
				vec3 diffuse = tex.rgb * vLightDirectionalColor * diffuseLight;

				vec3 H = normalize(L + vec3(0, 0, -1));
				float specularLight = pow(max(dot(v_Normal, H), 0.), vMaterialShiness);
				if(diffuseLight <= 0.)
					specularLight = 0.;
				vec3 specular = vMaterialSpecular * vLightDirectionalColor * specularLight;

				color.rgb = vMaterialEmissive + ambient + diffuse + specular;
				color.a = 1.0;

				gl_FragColor = color;
			}
		</script>
		<script type="text/javascript">
			CL3D.MeshBuffer.prototype.setVIMesh = function(mesh) {
				if (this.Vertices != mesh.vertices || this.Indices != mesh.indices) {
					this.Vertices = mesh.vertices;
					this.Indices = mesh.indices;
					this.update();
				}
			};

			CL3D.Renderer.prototype.MaterialUniforms = {};

			CL3D.Renderer.prototype.createMaterialTypeEx = function(vs, fs, uniforms, blendenabled, blendsfactor, blenddfactor) {
				var type = this.createMaterialType(vs, fs, blendenabled, blendsfactor, blenddfactor);

				this.MaterialUniforms[type] = uniforms;

				return type;
			};

			CL3D.Renderer.prototype.OnChangeMaterial = function(mattype) {
				var uniforms = this.MaterialUniforms[mattype];
				if (uniforms) {
					var gl = this.getWebGL();
					var program = this.getGLProgramFromMaterialType(mattype);
					$.each(uniforms, function(key, uniform) {
						var location = gl.getUniformLocation(program, key);

						while (typeof (uniform) == "function")
							uniform = uniform();

						if (typeof (uniform) == "number")
							gl.uniform1f(location, uniform);
						else
							switch (uniform.length) {
							case 1:
								gl.uniform1f(location, uniform[0]);
								break;
							case 2:
								gl.uniform2f(location, uniform[0], uniform[1]);
								break;
							case 3:
								gl.uniform3f(location, uniform[0], uniform[1], uniform[2]);
								break;
							case 4:
								gl.uniform4f(location, uniform[0], uniform[1], uniform[2], uniform[3]);
								break;
							default:
								throw "invalid uniform length: " + uniform.length;
							}
					});
				}
			};

			CL3D.QMeshSceneNode = function() {
				this.Rotation = new CL3D.Quaternion();
			};

			CL3D.QMeshSceneNode.prototype = new CL3D.MeshSceneNode();

			CL3D.QMeshSceneNode.prototype.getRelativeTransformation = function () {
				var trans = this.Rotation.getMatrix();
				trans.setTranslation(this.Pos);
				if (this.Scale.X != 1 || this.Scale.Y != 1 || this.Scale.Z != 1) {
					var a = new CL3D.Matrix4();
					a.setScale(this.Scale);
					trans = trans.multiply(a);
				}
				return trans;
			};

			CL3D.Quaternion.prototype.multiplyWithQuat = function(q) {
				return new CL3D.Quaternion(
					this.W * q.X + this.X * q.W + this.Y * q.Z - this.Z * q.Y,
					this.W * q.Y + this.Y * q.W + this.Z * q.X - this.X * q.Z,
					this.W * q.Z + this.Z * q.W + this.X * q.Y - this.Y * q.X,
					this.W * q.W - this.X * q.X - this.Y * q.Y - this.Z * q.Z
				);
			};
		</script>
		<script type="text/javascript">
			var CUBE_SPHERAL_RATE = 0.54;
			var CL, Scene, Cube;

			var util = {
				createVertex: function(pos, normal, tu, tv) {
					var v = new CL3D.Vertex3D(true);
					v.Pos = pos;
					if (normal)
						v.Normal = normal;
					if (tu || tu == 0)
						v.TCoords.X = tu;
					if (tv || tv == 0)
						v.TCoords.Y = tv;

					return v;
				},
				createSimpleCubeMesh: function(length) {
					length = length || 1;
					var half = length / 2;

					var vertices = [
						util.createVertex(new CL3D.Vect3d(-half, -half, -half)),
						util.createVertex(new CL3D.Vect3d(-half, -half, +half)),
						util.createVertex(new CL3D.Vect3d(-half, +half, -half)),
						util.createVertex(new CL3D.Vect3d(-half, +half, +half)),

						util.createVertex(new CL3D.Vect3d(+half, -half, -half)),
						util.createVertex(new CL3D.Vect3d(+half, -half, +half)),
						util.createVertex(new CL3D.Vect3d(+half, +half, -half)),
						util.createVertex(new CL3D.Vect3d(+half, +half, +half))
					];
					var indices = [
						0, 1, 2, 1, 3, 2,
						4, 6, 5, 5, 6, 7,
						1, 5, 3, 5, 7, 3,
						0, 2, 4, 2, 6, 4,
						2, 3, 7, 7, 6, 2,
						5, 1, 0, 0, 4, 5
					];

					return { vertices: vertices, indices: indices };
				},
				createCubeArrayMeshes: function(options) {
					options = options || {};
					options.Segments = options.Segments || 10;
					options.Spheral = options.Spheral || CUBE_SPHERAL_RATE;

					var grids = options.Segments * 1.5 + 1;
					var inv_grids = 1 / grids;

					var eachRange2D = function(ul, uh, vl, vh, elem) {
						for (var u = ul; u <= uh; ++u)
							for (var v = vl; v <= vh; ++v)
							elem(u, v);
					};

					var faceVerticesCount = (options.Segments + 1) * (options.Segments + 1);

					var getVertexIndex = function(f, u, v) {
						return faceVerticesCount * f + u * (options.Segments + 1) + v;
					};

					var indices = [];
					for (var f = 0; f < 6; ++f) {
						eachRange2D(0, options.Segments - 1, 0, options.Segments - 1, function(u, v) {
							indices.push(getVertexIndex(f, u, v));
							indices.push(getVertexIndex(f, u + 1, v + 1));
							indices.push(getVertexIndex(f, u + 1, v));

							indices.push(getVertexIndex(f, u, v));
							indices.push(getVertexIndex(f, u, v + 1));
							indices.push(getVertexIndex(f, u + 1, v + 1));
						});
					}

					var mendIndicesMap = {};
					var mendIndicesInitialized = false;

					var units = [];

					// traverse all units
					for (var ax = -1; ax <= 1; ++ax)
						for (var ay = -1; ay <= 1; ++ay)
							for (var az = -1; az <= 1; ++az) {
								var vertices = [];

								var xl = ax * (options.Segments + 1) - options.Segments / 2, xh = ax * (options.Segments + 1) + options.Segments / 2;
								var yl = ay * (options.Segments + 1) - options.Segments / 2, yh = ay * (options.Segments + 1) + options.Segments / 2;
								var zl = az * (options.Segments + 1) - options.Segments / 2, zh = az * (options.Segments + 1) + options.Segments / 2;

								eachRange2D(yl, yh, zl, zh, function(y, z) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(xl, y, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(zl, zh, yl, yh, function(z, y) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(xh, y, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(zl, zh, xl, xh, function(z, x) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, yl, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(xl, xh, zl, zh, function(x, z) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, yh, z).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(xl, xh, yl, yh, function(x, y) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, y, zl).multiplyWithScal(inv_grids), options.Spheral))); });
								eachRange2D(yl, yh, xl, xh, function(y, x) { vertices.push(util.createVertex(util.spherize(new CL3D.Vect3d(x, y, zh).multiplyWithScal(inv_grids), options.Spheral))); });

								var mended = 0;

								for (var f = 0; f < 6; ++f) {
									eachRange2D(0, options.Segments, 0, options.Segments, function(u, v) {
										var vertex = vertices[getVertexIndex(f, u, v)];

										// compute normal
										{
											var pos = vertex.Pos;
											var normals = [];
											var L, R, U, D;

											L = (u > 0) && (vertices[getVertexIndex(f, u - 1, v)].Pos.substract(pos));
											R = (u < options.Segments) && (vertices[getVertexIndex(f, u + 1, v)].Pos.substract(pos));
											U = (v > 0) && (vertices[getVertexIndex(f, u, v - 1)].Pos.substract(pos));
											D = (v < options.Segments) && (vertices[getVertexIndex(f, u, v + 1)].Pos.substract(pos));

											if (L && U)
												normals.push(U.crossProduct(L).getNormalized());
											if (L && D)
												normals.push(L.crossProduct(D).getNormalized());
											if (R && U)
												normals.push(R.crossProduct(U).getNormalized());
											if (R && D)
												normals.push(D.crossProduct(R).getNormalized());

											vertex.Normal = new CL3D.Vect3d(0, 0, 0);
											$.each(normals, function(i, n) {
												vertex.Normal.addToThis(n);
											});
											vertex.Normal.multiplyWithScal(1 / normals.length);
											vertex.Normal.normalize();
										}

										var wuv = util.xyzToWuv(pos);
										vertex.TCoords.X = wuv.U;
										vertex.TCoords.Y = wuv.V;

										// append a mend vertex
										if (pos.Z == 0) {
											++mended;

											if (!mendIndicesInitialized)
												mendIndicesMap[getVertexIndex(f, u, v)] = vertices.length;

											var newVertex = vertex;
											if (vertex.TCoords.X == 0) {
												newVertex = new CL3D.Vertex3D(true);
												newVertex.Pos = vertex.Pos;
												newVertex.Normal = vertex.Normal;
												newVertex.TCoords.Y = vertex.TCoords.Y;
												newVertex.TCoords.X = 1;
											}

											vertices.push(newVertex);
										}
									});
								}

								units.push({ vertices: vertices, indices: indices, mended: mended });

								mendIndicesInitialized = mendIndicesInitialized || mended;
							}

					// build mendIndices
					var mendIndices = [];
					for (var f = 0; f < 6; ++f) {
						eachRange2D(0, options.Segments - 1, 0, options.Segments - 1, function(u, v) {
							var i00 = getVertexIndex(f, u, v);
							var i10 = getVertexIndex(f, u + 1, v);
							var i01 = getVertexIndex(f, u, v + 1);
							var i11 = getVertexIndex(f, u + 1, v + 1);

							switch(f) {
								case 0:
								case 3:
									i01 = mendIndicesMap[i01] || i01;
									i11 = mendIndicesMap[i11] || i11;

									break;
								case 1:
								case 2:
									i10 = mendIndicesMap[i10] || i10;
									i11 = mendIndicesMap[i11] || i11;

									break;
							}

							mendIndices.push(i00);
							mendIndices.push(i11);
							mendIndices.push(i10);

							mendIndices.push(i00);
							mendIndices.push(i01);
							mendIndices.push(i11);
						});
					}

					$.each(units, function(i, unit){
						if(unit.mended)
							unit.indices = mendIndices;
					});

					return units;
				},
				spherize: function(v, k) {
					k = k || CUBE_SPHERAL_RATE;

					var m = v.getLength();
					var r = Math.max(Math.abs(v.X), Math.max(Math.abs(v.Y), Math.abs(v.Z)));
					var radius = m * k + r * (1 - k);

					return new CL3D.Vect3d(v.X * radius / m, v.Y * radius / m, v.Z * radius / m);
				},
				xyzToWuv: function(v) {
					var m = v.getLength();
					var r = Math.sqrt(v.X * v.X + v.Z * v.Z);

					var V = Math.acos(v.Y / m) / Math.PI;
					var U = r == 0 ? 0 : Math.acos(v.X / r) / (Math.PI * 2);
					if (v.Z < 0)
						U = 1 - U;

					return {W: m, U: U, V: V};
				}
			};
			util.SimpleCubeMesh = util.createSimpleCubeMesh(1);
			util.CubeArrayMeshes = util.createCubeArrayMeshes();

			$(function() {
				var canvas = $("#cube-earth");
				canvas.attr("width", canvas.width());
				canvas.attr("height", canvas.height());

				CL = new CL3D.CopperLicht("cube-earth", null, 30);
				if (CL.initRenderer({ antialias: true })) {
					Scene = new CL3D.Scene();
					CL.addScene(Scene);

					Scene.setBackgroundColor(0x00000000);

					var cam = new CL3D.CameraSceneNode();
					cam.Pos = new CL3D.Vect3d(0, 0, 1);
					cam.setTarget(new CL3D.Vect3d(0, 0, 0));
					cam.setFov(Math.PI * 0.3);
					var animator = new CL3D.AnimatorCameraModelViewer(cam, CL, [0]);
					cam.addAnimator(animator);
					animator.Radius = 4;
					Scene.getRootSceneNode().addChild(cam);
					Scene.setActiveCamera(cam);
					cam.setAspectRatio(canvas.width() / canvas.height());

					var cube = new CL3D.SceneNode();
					Scene.getRootSceneNode().addChild(cube);

					var cubeMat = CL.getRenderer().createMaterialTypeEx($("#vs-3dposition").text(), $("#fs-directionallight").text(), {
						vLightAmbientColor: [0.5, 0.5, 0.5],
						vLightDirection: [-1, -0.8, -1],
						vLightDirectionalColor: [0.7, 0.7, 0.7],
						vMaterialEmissive: [0, 0, 0],
						vMaterialSpecular: [0.8, 0.8, 0.8],
						vMaterialShiness: 64
					});

					$.each(util.CubeArrayMeshes, function(i, unit) {
						var buffer = new CL3D.MeshBuffer();
						buffer.setVIMesh(unit);
						buffer.Mat.Type = cubeMat;
						buffer.Mat.Tex1 = CL.getTextureManager().getTexture("../res/images/earth.jpg", true);

						var mesh = new CL3D.Mesh();
						mesh.AddMeshBuffer(buffer);

						var node = new CL3D.QMeshSceneNode();
						node.setMesh(mesh);
						cube.addChild(node);
					});

					Cube = new CubeArray(cube.Children);
				}
			});

			var CubeArray = function(nodes) {
				var self = this;

				this.Nodes = nodes;
				this.Array = {};

				$.each(nodes, function(i, node){
					var pos = [Math.floor(i / 9) % 3 - 1, Math.floor(i / 3) % 3 - 1, i % 3 - 1];

					node.ArrayPos = pos;
					node.RotationBase = node.Rotation;
				});
				this.updateArray();

				this.ScrewPoints = [
					{pos: util.spherize(new CL3D.Vect3d(1, 2 / 3, 0)),		face: [0, 1, 0]},
					{pos: util.spherize(new CL3D.Vect3d(-1, 2 / 3, 0)),		face: [0, 1, 0]},
					{pos: util.spherize(new CL3D.Vect3d(0, 2 / 3, 1)),		face: [0, 1, 0]},
					{pos: util.spherize(new CL3D.Vect3d(0, 2 / 3, -1)),		face: [0, 1, 0]},

					{pos: util.spherize(new CL3D.Vect3d(1, -2 / 3, 0)),		face: [0, -1, 0]},
					{pos: util.spherize(new CL3D.Vect3d(-1, -2 / 3, 0)),	face: [0, -1, 0]},
					{pos: util.spherize(new CL3D.Vect3d(0, -2 / 3, 1)),		face: [0, -1, 0]},
					{pos: util.spherize(new CL3D.Vect3d(0, -2 / 3, -1)),	face: [0, -1, 0]},

					{pos: util.spherize(new CL3D.Vect3d(2 / 3, 1, 0)),		face: [1, 0, 0]},
					{pos: util.spherize(new CL3D.Vect3d(2 / 3, -1, 0)),		face: [1, 0, 0]},
					{pos: util.spherize(new CL3D.Vect3d(2 / 3, 0, 1)),		face: [1, 0, 0]},
					{pos: util.spherize(new CL3D.Vect3d(2 / 3, 0, -1)),		face: [1, 0, 0]},

					{pos: util.spherize(new CL3D.Vect3d(-2 / 3, 1, 0)),		face: [-1, 0, 0]},
					{pos: util.spherize(new CL3D.Vect3d(-2 / 3, -1, 0)),	face: [-1, 0, 0]},
					{pos: util.spherize(new CL3D.Vect3d(-2 / 3, 0, 1)),		face: [-1, 0, 0]},
					{pos: util.spherize(new CL3D.Vect3d(-2 / 3, 0, -1)),	face: [-1, 0, 0]},

					{pos: util.spherize(new CL3D.Vect3d(1, 0, 2 / 3)),		face: [0, 0, 1]},
					{pos: util.spherize(new CL3D.Vect3d(-1, 0, 2 / 3)),		face: [0, 0, 1]},
					{pos: util.spherize(new CL3D.Vect3d(0, 1, 2 / 3)),		face: [0, 0, 1]},
					{pos: util.spherize(new CL3D.Vect3d(0, -1, 2 / 3)),		face: [0, 0, 1]},

					{pos: util.spherize(new CL3D.Vect3d(1, 0, -2 / 3)),		face: [0, 0, -1]},
					{pos: util.spherize(new CL3D.Vect3d(-1, 0, -2 / 3)),	face: [0, 0, -1]},
					{pos: util.spherize(new CL3D.Vect3d(0, 1, -2 / 3)),		face: [0, 0, -1]},
					{pos: util.spherize(new CL3D.Vect3d(0, -1, -2 / 3)),	face: [0, 0, -1]},
				];
			};

			CubeArray.prototype.getArrayNode = function(i, j, k) {
				return this.Array[i][j][k];
			};

			CubeArray.prototype.setArrayNode = function(node, i, j, k) {
				this.Array[i] = this.Array[i] || {};
				this.Array[i][j] = this.Array[i][j] || {};
				this.Array[i][j][k] = node;
			};

			CubeArray.prototype.updateArray = function() {
				var self = this;

				$.each(this.Nodes, function(i, node){
					self.setArrayNode(node, node.ArrayPos[0], node.ArrayPos[1], node.ArrayPos[2]);
				});
			};

			CubeArray.prototype.setFaceRotation = function(face, angle) {
				this.traverseArrayFace(face, function(node){
					var r = new CL3D.Quaternion();
					r.setFromEuler(face[0] * angle, face[1] * angle, face[2] * angle);
					node.Rotation = node.RotationBase.multiplyWithQuat(r);
				});
			};

			CubeArray.prototype.traverseArrayFace = function(face, callback) {
				for (var i = -1; i <= 1; ++i)
					for (var j = -1; j <= 1; ++j)
						for (var k = -1; k <= 1; ++k) {
							if ((!face[0] || face[0] == i) && (!face[1] || face[1] == j) && (!face[2] || face[2] == k))
								callback(this.Array[i][j][k]);
						}
			};
		</script>
	</head>
	<body>
		<canvas id="cube-earth"></canvas>
	</body>
</html>
