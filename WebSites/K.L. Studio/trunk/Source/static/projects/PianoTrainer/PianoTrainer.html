<!DOCTYPE html>
<html>
	<head>
		<title>Piano Trainer</title>
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<style type="text/css">
			html
			{
				font-family: Verdana, Arial, Helvetica, sans-serif;
			}

			body
			{
				color: #ccc;
				background: #333;
				margin: 0;
				overflow: hidden;
				position: relative;
				height: 100%;
			}

			body.drag-hover
			{
				background: #3d5b3d;
			}

			#header
			{
				background: -webkit-gradient(linear,left top,left bottom,from(#444),to(#111));
				padding: 1px 0;
				box-shadow: 0 2px 4px rgba(0,0,0,.4);
			}

			#header p
			{
				text-align: center;
				margin: 1em 0;
			}

			#header .wrapper > *
			{
				vertical-align: middle;
			}

			#loading
			{
				position: fixed;
				top: 0;
				width: 100%;
				height: 100%;
				background: no-repeat no-repeat url(/res/images/loading-5d.gif) center;
				background-color: rgba(255, 255, 255, 0.4);
			}

			.wrapper
			{
				width: 1000px;
				margin: 0 auto;
			}

			#playback
			{
				display: inline-block;
			}

			#playback span
			{
				display: inline-block;
			}

			#playback > span, #playback-time > span, #input-device-bar > *
			{
				vertical-align: middle;
			}

			.image-button
			{
				transition-property: opacity;
				transition-duration: .2s;
				opacity: 0.7;
				cursor: pointer;
			}

			.image-button:hover
			{
				opacity: 1;
			}

			.image-button:active
			{
				opacity: 0.85;
			}

			#playback-record
			{
				background: url(/res/images/record.png);
				border: none;
				width: 32px;
				height: 32px;
			}

			.recording #playback-record
			{
				background: url(/res/images/recording.png);
				opacity: 0.9;
			}

			.recording #playback-record.fade
			{
				background: url(/res/images/record.png);
			}

			.recording #playback-record:hover
			{
				opacity: 1;
			}

			.recording #playback-play, .recording #playback-progress, .recording #playback-source, .recording #playback-metainfo, .recording #playback-save
			{
				opacity: 0.3;
			}

			#playback-time
			{
				margin-left: 20px;
			}

			#playback-progress
			{
				width: 240px;
				height: 32px;
				border: 1px solid #000;
				border-radius: 5px;
				box-shadow: 0 0 16px rgba(255, 255, 255, 0.4);
				overflow: hidden;
				background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0,#444),color-stop(1,rgba(0,0,0,.7)));
				cursor: pointer;
				text-align: left;
			}

			#playback-progress-cursor
			{
				display: inline-block;
				position: relative;
				background: #999;
				background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0,rgba(0,0,0,0)),color-stop(1,rgba(0,0,0,.5)));
				transition-property: background;
				transition-duration: .3s;
				transition-timing-function: linear;
				height: 100%;
			}

			#playback-progress:hover #playback-progress-cursor
			{
				background-color: #0088e9;
			}

			#playback-time-text
			{
				margin-left: 1em;
			}

			#playback-source
			{
				margin-left: 20px;
				font-size: 20px;
				line-height: 24px;
				width: 16em;
				height: 24px;
				border-radius: 5px;
				white-space: nowrap;
				overflow: hidden;
				cursor: pointer;
				text-align: center;
				border: solid 1px transparent;
				transition-property: color;
				transition-duration: .3s;
			}

			#playback-source:hover
			{
				overflow: visible;
				color: #fff;
				text-shadow: rgba(0,0,0,0.7) 2px 2px 1px;
			}

			#playback-source-file
			{
				display: none;
			}

			#playback-save
			{
				display: inline-block;
				vertical-align: middle;
				width: 32px;
				height: 32px;
				background: url(/res/images/save.png) center no-repeat;
			}

			#playback-mode
			{
				margin-left: 8px;
				width: 1.6em;
			}

			#playback-tempo
			{
				font-size: 60%;
			}

			#playback-speed
			{
				font-size: 80%;
				width: 4em;
			}

			.drag-hover #playback-source
			{
				border-color: #fc0;
			}

			#midi-pugin
			{
				visibility: hidden;
				position: absolute;
				z-index: -1000;
			}

			#input-device-bar
			{
				display: none;
			}

			#input-device
			{
				margin-left: 2em;
				width: 12em;
				color: inherit;
				background: inherit;
				font-family: inherit;
				border-color: #666;
			}

			#input-device-refresh
			{
				width: 20px;
				height: auto;
			}

			#range-controls
			{
				margin: 22px 0 8px !important;
			}

			#range-bar
			{
				opacity: 0.8;
				transition-property: opacity, background;
				transition-duration: .2s;
				position: relative;
				display: inline-block;
				width: 900px;
			}

			#range-bar:hover
			{
				opacity: 1;
			}

			#range-bar .mask
			{
				position: absolute;
				display: inline-block;
				top: 0;
				height: 100%;
				cursor: pointer;
			}

			#range-bar .mask:hover
			{
				border-color: #af4;
			}

			#range-bar .mask.hold
			{
				border-color: #f00;
			}

			#range-mask-left, #range-mask-right
			{
				background-color: rgba(0, 0, 0, 0.7);
				background: -webkit-gradient(linear,right top,right bottom,color-stop(0,rgba(0,0,0,0.8)),color-stop(0.5,rgba(0,0,0,0.3)),color-stop(1,rgba(0,0,0,0.8)));
			}

			#range-mask-left
			{
				border-right: 2px solid transparent;
				border-top-left-radius: 12px;
				border-bottom-left-radius: 12px;
			}

			#range-mask-right
			{
				border-left: 2px solid transparent;
				border-top-right-radius: 12px;
				border-bottom-right-radius: 12px;
			}

			#range-mask-middle
			{
				border-left: 2px solid transparent;
				border-right: 2px solid transparent;
			}

			#range-mask-left:hover
			{
				background: -webkit-gradient(linear,left top,right top,color-stop(0,rgba(80,80,80,1)),color-stop(0.8,rgba(80,120,80,0.9)),color-stop(1,rgba(0,120,0,0.4)));
			}

			#range-mask-right:hover
			{
				background: -webkit-gradient(linear,right top,left top,color-stop(0,rgba(80,80,80,1)),color-stop(0.8,rgba(80,120,80,0.9)),color-stop(1,rgba(0,120,0,0.4)));
			}

			#range-mask-left
			{
				left: 0;
			}

			#range-mask-right
			{
				right: 0;
			}

			#range-mask-middle
			{
				background-color: transparent;
				background: -webkit-gradient(linear,right top,right bottom,color-stop(0,rgba(0,0,0,0.3)),color-stop(0.5,rgba(0,0,0,0)),color-stop(1,rgba(0,0,0,0.3)));
			}

			#range-mask-middle:hover
			{
				background: -webkit-gradient(linear,left top,right top,color-stop(0,rgba(0,128,0,0.3)),color-stop(0.5,rgba(0,128,0,0)),color-stop(1,rgba(0,128,0,0.3)));
			}

			#range-canvas
			{
				height: 38px;
			}

			#keyboard-canvas, #score-canvas
			{
				position: relative;
			}

			#keyboard .key
			{
				cursor: pointer;
			}

			#score-canvas
			{
				z-index: -100;
				height: 100000px;
				background-color: black;
			}

			#klstudio
			{
				display: block;
				position: fixed;
				right: 0;
				bottom: 0;
				width: 140px;
				height: 34px;
				border-top-left-radius: 9px;
				background-image: url(/res/images/K.L._Stuidio_Logo_small.png);
				background-size: 128px 25px;
				background-repeat: no-repeat no-repeat;
				background-position: 6px 5px;
				background-color: rgba(255, 255, 255, 0.4);
			}

			#klstudio:hover
			{
				background-color: rgba(255, 255, 255, 0.9);
				box-shadow: 0px 0px 60px #fff;
			}

			.full-screen #klstudio
			{
				display: none !important;
			}
		</style>
		<!-- SVG styles -->
		<style type="text/css">
			#range-keyboard .white-key
			{
				fill: white;
				stroke: #333;
				stroke-width: 1px;
			}

			#range-keyboard .black-key
			{
				fill: black;
			}

			#range-keyboard .white-key:hover, #range-keyboard .white-key.active
			{
				fill: #aaf;
			}

			#range-keyboard .black-key:hover, #range-keyboard .black-key.active
			{
				fill: #22d;
			}

			#range-keyboard-labels text
			{
				text-anchor: middle;
				font-size: 7px;
			}

			/* key of Middle C */
			#keyboard .key[data-note="60"]
			{
				fill: #fff0f0;
				stroke: black;
				stroke-width: 2;
			}
			#range-keyboard .key[data-note="60"]
			{
				fill: #fff0f0;
				stroke: black;
			}

			#keyboard .white-key
			{
				fill: white;
				stroke: #333;
				stroke-width: 1px;
			}

			#keyboard .black-key
			{
				fill: black;
			}

			#keyboard .white-key:hover
			{
				fill: #eef;
			}

			#keyboard .white-key.active
			{
				fill: #aaf;
			}

			#keyboard .black-key:hover
			{
				fill: #335;
			}

			/*#keyboard .black-key.active
			{
				fill: #22d !important;
			}*/

			#keyboard-labels text
			{
				text-anchor: middle;
				font-size: 12px;
				fill: #bbb;
			}

			.note-separator
			{
				stroke: white;
				stroke-width: 1px;
				opacity: 0.2;
			}

			.group-separator
			{
				opacity: 0.4;
			}

			.note-bar
			{
				fill: white;
				/*fill: url(#svgdef-gradient-white);*/
				opacity: 0;
			}

			.note-bar.active
			{
				opacity: 1;
			}

			.note-bar.active.matched
			{
				fill: #2a3;
			}

			.note-bar.active.error
			{
				fill: #c22;
			}

			#score-music .pitch-0, #keyboard .key.active.pitch-0
			{
				fill: #ff0000;
			}

			#score-music .pitch-1, #keyboard .key.active.pitch-1
			{
				fill: #ff6500;
			}

			#score-music .pitch-2, #keyboard .key.active.pitch-2
			{
				fill: #ffb400;
			}

			#score-music .pitch-3, #keyboard .key.active.pitch-3
			{
				fill: #ffe400;
			}

			#score-music .pitch-4, #keyboard .key.active.pitch-4
			{
				fill: #eaff00;
			}

			#score-music .pitch-5, #keyboard .key.active.pitch-5
			{
				fill: #6cff00;
			}

			#score-music .pitch-6, #keyboard .key.active.pitch-6
			{
				fill: #00ff96;
			}

			#score-music .pitch-7, #keyboard .key.active.pitch-7
			{
				fill: #00fff6;
			}

			#score-music .pitch-8, #keyboard .key.active.pitch-8
			{
				fill: #008cff;
			}

			#score-music .pitch-9, #keyboard .key.active.pitch-9
			{
				fill: #0003ff;
			}

			#score-music .pitch-10, #keyboard .key.active.pitch-10
			{
				fill: #ae00ff;
			}

			#score-music .pitch-11, #keyboard .key.active.pitch-11
			{
				fill: #f600ff;
			}

			.channel .note
			{
				stroke: #aaa;
				stroke-width: 2;
			}

			.channel .note.active
			{
				stroke: #fff !important;
				stroke-width: 5 !important;
				opacity: 1 !important;
			}

			.channel[data-channel="0"] .note
			{
				stroke-width: 0;
			}

			.channel[data-channel="1"] .note
			{
				stroke: #058dc7;
			}

			.channel[data-channel="2"] .note
			{
				stroke: #50b432;
			}

			.channel[data-channel="3"] .note
			{
				stroke: #ed561b;
			}

			.channel[data-channel="4"] .note
			{
				stroke: #edef00;
			}

			.channel[data-channel="5"] .note
			{
				stroke: #24cbe5;
			}

			.channel[data-channel="6"] .note
			{
				stroke: #64e572;
			}

			.channel[data-channel="7"] .note
			{
				stroke: #ff9655;
			}

			.channel[data-channel="8"] .note
			{
				stroke: #fff263;
			}

			.channel[data-channel="9"] .note
			{
				stroke: #6af9c4;
			}

			.channel[data-channel="10"] .note
			{
				stroke: #b2deff;
			}

			.channel[data-channel="11"] .note
			{
				stroke: #ffb88c;
			}

			.channel[data-channel="12"] .note
			{
				stroke: #fff79f;
			}

			.pedal
			{
				opacity: 0.3;
			}

			.pedal-Sustain
			{
				fill: #00baff;
			}

			.pedal-Sostenuto
			{
				fill: #ff7800;
			}

			.pedal-Soft
			{
				fill: #ff00cc;
			}

			.beat-bar
			{
				stroke: white;
				stroke-width: 1px;
				opacity: 0.1;
				stroke-dasharray: 3;
			}

			.beat-bar.bar-bar
			{
				opacity: 0.3;
				stroke-dasharray: 6, 2;
			}

			.end-bar
			{
				stroke: white;
				opacity: 0.8;
				stroke-width: 1px;
			}

			.end-bar2
			{
				stroke: white;
				opacity: 0.8;
				stroke-width: 1.6px;
			}

			#svgdef-score-cursor
			{
				stroke: #ccc;
				stroke-width: 2;
			}

			#svgdef-score-cursor.active
			{
				stroke: #8f8;
			}

			#score-work-rect
			{
				display: none;
				fill: #8f8;
				opacity: 0.1;
			}
		</style>
		<script src="../../js/jquery.js" type="text/javascript"></script>
		<script src="../../js/jquery.svg.js" type="text/javascript"></script>
		<script src="../../js/MIDI/AudioDetect.js" type="text/javascript"></script>
		<script src="../../js/MIDI/LoadPlugin.js" type="text/javascript"></script>
		<script src="../../js/MIDI/Plugin.js" type="text/javascript"></script>
		<script src="../../js/MIDI/Player.js" type="text/javascript"></script>
		<script src="../../js/MIDI/Window/DOMLoader.XMLHttp.js" type="text/javascript"></script>
		<script src="../../js/MIDI/Window/DOMLoader.script.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/WebMIDIAPI.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/Base64.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/base64binary.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/replayer.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/midifile.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/midifileEx.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/stream.js" type="text/javascript"></script>
		<script src="../../js/MIDI/inc/streamEx.js" type="text/javascript"></script>
		<script src="../../js/MusicalUtils.js" type="text/javascript"></script>
		<script type="text/javascript">
			var MidiIO = null;

			var PinaoConfig = {
				NoteStart: 21,
				NoteEnd: 108,
				MiddleC: 60,
				KeySerials: {
					White: [0, 2, 4, 5, 7, 9, 11],
					BlackPosition: {
						1: 0.94,
						3: 2.06,
						6: 3.92,
						8: 5,
						10: 6.08
					}
				},
				KeyWidth: 40,
				KeyHeight: 60,
				RangeKeyWidth: 11
			};

			var PedalControllerTypes = {
				64: "Sustain",
				65: "Portamento",
				66: "Sostenuto",
				67: "Soft"
			};

			var PedalControllerNumber = {};
			for (var i in PedalControllerTypes)
				PedalControllerNumber[PedalControllerTypes[i]] = i;

			Date.prototype.format = function (format) {
				/*
				* eg:format="yyyy-MM-dd hh:mm:ss";
				*/
				var o = {
					"M+": this.getMonth() + 1,  //month
					"d+": this.getDate(),     //day
					"h+": this.getHours(),    //hour
					"m+": this.getMinutes(),  //minute
					"s+": this.getSeconds(), //second
					"q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
					"S": this.getMilliseconds() //millisecond
				};

				if (/(y+)/.test(format)) {
					format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
				}

				for (var k in o) {
					if (new RegExp("(" + k + ")").test(format)) {
						format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
					}
				}
				return format;
			};

			var ScoreTimeScale = 0.08;

			var MetaData = $.parseJSON(localStorage.MetaData) || {};

			var KeyMap = $.parseJSON(localStorage.KeyMap) || {
				// number keys
				49: 60,
				50: 62,
				51: 64,
				52: 65,
				53: 67,
				54: 69,
				55: 71,
				56: 72,
				57: 74,
				48: 76,
				189: 77,
				187: 79,

				// up letters
				81: 76,
				87: 77,
				69: 79,
				82: 81,
				84: 83,
				89: 84,
				85: 86,
				73: 88,
				79: 89,
				80: 91,
				219: 93,
				221: 95,

				// middle letters
				65: 60,
				83: 62,
				68: 64,
				70: 65,
				71: 67,
				72: 69,
				74: 71,
				75: 72,
				76: 74,
				186: 76,
				222: 77,
				220: 79,

				// bottom letters
				90: 48,
				88: 50,
				67: 52,
				86: 53,
				66: 55,
				78: 57,
				77: 59,
				188: 60,
				190: 62,
				191: 64
			};

			var KeyStatus = {};

			var PitchWheelValue = 0;

			var MidiTimeStampOffset = null;

			var Follower = function () {
				this.State = Follower.States.Idle;
				this.Handler = null;
				this.LastMatchTime = 0;
				this.MatchedNotes = {};
				this.LastNoteIndex = 0;
				this.WorkRegion = { upper: 0, lower: 0 };
				this.EstimatedSpeed = 1;
			};

			Follower.States = {
				Shut: 0,
				Idle: 1,
				Following: 2,
				Interrupt: 3
			};

			Follower.Config = {
				UpdateInterval: 50,
				CurosrStableHeight: 220,
				SuspendTime: 2400,
				TimeTolerant: 500
			};

			Follower.prototype.start = function () {
				$("#score-cursor").show();

				this.State = Follower.States.Idle;

				var self = this;

				this.Handler = setInterval(function () { self.update(); }, Follower.Config.UpdateInterval);

				//console.log("Follower started.");
			};

			Follower.prototype.stop = function () {
				clearInterval(this.Handler);

				this.State = Follower.States.Shut;

				$("#score-cursor").hide();
				$("#score-work-rect").hide();

				//console.log("Follower stopped.");
			};

			Follower.prototype.update = function () {
				// update canvas scroll
				var scrollPosition = scoreScrollPosition();
				var cursorHeight = MIDI.Player.currentTime * ScoreTimeScale - scrollPosition;
				var deltaHeight = (cursorHeight - Follower.Config.CurosrStableHeight) * 0.16;
				if (Math.abs(deltaHeight) < 0.1)
					deltaHeight = cursorHeight - Follower.Config.CurosrStableHeight;
				var canvasTop = -Math.max(scrollPosition + deltaHeight, 0);

				if (canvasTop != $("#score-canvas").css("top"))
					$("#score-canvas").css("top", canvasTop);


				var now = Date.now();

				switch (this.State) {
					case Follower.States.Idle:
						$("#score-work-rect").hide();

						break;
					case Follower.States.Following:
						// time out
						if (now - this.LastMatchTime > Follower.Config.SuspendTime) {
							this.State = Follower.States.Idle;
							removeClass($("#svgdef-score-cursor"), "active");
							$("#score-work-rect").hide();
						}

						this.updateWorkRegion();

						break;
				}

				/*if (this.State != Follower.States.Playing)
					if (PitchWheelValue != 0) {
						this.State = Follower.States.Idle;
						scrollScore(-PitchWheelValue * 1000);
					}*/

				updateScorePosition();
			};

			Follower.prototype.updateWorkRegion = function () {
				this.WorkRegion.upper = MIDI.Player.currentTime - Follower.Config.TimeTolerant;
				if (Object.keys(this.MatchedNotes).length) {
					var lower = MIDI.Player.currentTime;
					for (var n in this.MatchedNotes) {
						var note = ScoreNotations.notes[this.MatchedNotes[n]];
						var end = note.start + note.duration;
						if (end > lower)
							lower = end;
					}

					this.WorkRegion.lower = lower + Follower.Config.TimeTolerant;
				}
				else {
					this.WorkRegion.lower = MIDI.Player.currentTime + (Date.now() - this.LastMatchTime) + Follower.Config.TimeTolerant;
				}

				$("#score-work-rect").attr({
					y: this.WorkRegion.upper * ScoreTimeScale,
					height: (this.WorkRegion.lower - this.WorkRegion.upper) * ScoreTimeScale
				});
				$("#score-work-rect").show();
			};

			Follower.prototype.pushMatchedNote = function (note, index) {
				this.MatchedNotes[note] = index;
				this.LastNoteIndex = index;
				this.LastMatchTime = Date.now();

				addClass($(".note[data-index='" + index + "']"), "active");

				var bar = $(".note-bar[data-note='" + note + "']");
				addClass(bar, "matched");
			};

			Follower.prototype.popMatchedNote = function (note) {
				var index = this.MatchedNotes[note];
				delete this.MatchedNotes[note];

				removeClass($(".note[data-index='" + index + "']"), "active");

				var bar = $(".note-bar[data-note='" + note + "']");
				removeClass(bar, "matched");
			};

			Follower.prototype.onNoteOn = function (note) {
				switch (this.State) {
					case Follower.States.Idle:
						var index = searchNotation(note, { begin: MIDI.Player.currentTime, end: MIDI.Player.currentTime + Follower.Config.TimeTolerant });
						if (index === null)
							index = searchNotation(note, { end: MIDI.Player.currentTime, backwards: true });

						//console.log(index, ScoreNotations.notes[index]);
						if (index !== null) {
							this.MatchedNotes = {};
							this.pushMatchedNote(note, index);

							MIDI.Player.currentTime = ScoreNotations.notes[index].start;
							updateScorePosition();
							this.State = Follower.States.Following;

							addClass($("#svgdef-score-cursor"), "active");

							this.updateWorkRegion();
						}

						break;
					case Follower.States.Following:
						var index = searchNotation(note, { begin: MIDI.Player.currentTime, end: this.WorkRegion.lower, referenceIndex: this.LastNoteIndex });
						if (index === null)
							index = searchNotation(note, { begin: this.WorkRegion.upper, end: MIDI.Player.currentTime, referenceIndex: this.LastNoteIndex, backwards: true });

						if (index === null) {
							// error note pressed
							addClass($(".note-bar[data-note='" + note + "']"), "error");
						}
						else {
							this.pushMatchedNote(note, index);

							this.updateWorkRegion();
						}

						break;
				}
			};

			Follower.prototype.onNoteOff = function (note) {
				if (this.MatchedNotes[note] || this.MatchedNotes[note] === 0) {
					var data = ScoreNotations.notes[this.MatchedNotes[note]];
					this.popMatchedNote(note);

					switch (this.State) {
						case Follower.States.Following:
							MIDI.Player.currentTime = data.start + data.duration;

							this.LastMatchTime = Date.now();

							break;
					}

					this.updateWorkRegion();
				}
				else {
					removeClass($(".note-bar[data-note='" + note + "']"), "error");
				}
			};


			var Recorder = function () {
				this.Recording = false;
				this.Waiting = false;
				this.ButtonFlickerHandle = null;
				this.AnimationHandle = null;
				this.BeginTime = Date.now();
				this.Data = null;
			};

			Recorder.MidiMetaData = {
				ticksPerBeat: 96,
				microsecondsPerBeat: 500000
			};
			Recorder.MidiMetaData.secondToTicks = Recorder.MidiMetaData.ticksPerBeat * 1000 / Recorder.MidiMetaData.microsecondsPerBeat;

			Recorder.prototype.toggleRecord = function () {
				this.Recording = !this.Recording;

				if (this.Recording)
					this.prepareRecord();
				else
					this.endRecord();
			};

			Recorder.prototype.isRecording = function () {
				return this.Recording;
			};

			Recorder.prototype.prepareRecord = function (note) {
				MIDI.Player.stop();
				MIDI.Player.clearAnimation();

				$("#playback-play").attr("src", "/res/images/play.png");

				$("#playback").addClass("recording");
				$("#score-music").empty();
				$("#playback-source").empty();

				this.Waiting = this.Recording;
				this.ButtonFlickerHandle = setInterval(function () {
					if ($("#playback-record").hasClass("fade"))
						$("#playback-record").removeClass("fade");
					else
						$("#playback-record").addClass("fade");
				}, 400);

				$("#playback-time-text").text(toMinutesSeconds(0));

				this.SvgScore = svg("#score-music");
				//this.SvgChannel = svg(this.SvgScore.group({ class: "channel-container" }));
				this.SvgChannels = {};
				this.SvgPedals = svg(this.SvgScore.group({ class: "pedals" }));

				this.ChannelStatus = [];
				this.PedalStatus = {};

				this.Tracks = [[]];
				this.Tracks[0].push({ time: 0, type: "meta", subtype: "timeSignature", numerator: 4, denominator: 4, thirtyseconds: 8 });
				this.Tracks[0].push({ time: 0, type: "meta", subtype: "setTempo", microsecondsPerBeat: Recorder.MidiMetaData.microsecondsPerBeat });

				Fll.stop();
			};

			Recorder.prototype.beginRecord = function (note) {
				this.Waiting = false;

				clearInterval(this.ButtonFlickerHandle);
				this.ButtonFlickerHandle = null;

				$("#playback-record").removeClass("fade");

				this.BeginTime = Date.now();

				var self = this;
				this.AnimationHandle = setInterval(function () { self.onAnimation(); }, 30);

				this.Data = [];
			};

			Recorder.prototype.endRecord = function (note) {
				$("#playback").removeClass("recording");

				if (this.ButtonFlickerHandle)
					clearInterval(this.ButtonFlickerHandle);

				if (this.AnimationHandle)
					clearInterval(this.AnimationHandle);

				this.saveData();

				Fll.start();
			};

			Recorder.prototype.saveData = function () {
				var header = { formatType: 0, ticksPerBeat: Recorder.MidiMetaData.ticksPerBeat };

				this.Tracks[0].push({ time: this.elapsedTime(), type: "meta", subtype: "endOfTrack" });

				// compute deltaTime for events
				this.Tracks[0].sort(function (e1, e2) { return e1.time - e2.time; });
				//console.log("saveData", this.Tracks[0]);
				for (var i in this.Tracks[0]) {
					this.Tracks[0][i].deltaTime = (this.Tracks[0][i].time - (i > 0 ? this.Tracks[0][i - 1].time : 0)) * Recorder.MidiMetaData.secondToTicks;
				}

				var midiData = OMidiFile(header, this.Tracks);

				localStorage.SourceData = "data:audio/mid;base64," + btoa(midiData);
				localStorage.SourceName = "Recording " + new Date().format("yyyy-MM-dd hh.mm.ss.mid");
				MIDI.Player.loadFile(localStorage.SourceData, function () {
					MIDI.Player.currentTime = 0;

					paintScore();
					updateScorePosition();
				});

				$("#playback-source").text(localStorage.SourceName);
				$("#playback-save").attr("href", localStorage.SourceData);
				$("#playback-save").attr("download", localStorage.SourceName);
			};

			Recorder.prototype.elapsedTime = function () {
				return Date.now() - this.BeginTime;
			};

			Recorder.prototype.getTimeStamp = function (time) {
				return MidiTimeStampOffset ? (time * 1000 + MidiTimeStampOffset - this.BeginTime) : this.elapsedTime();
			}

			Recorder.prototype.getChannel = function (channel) {
				if (this.SvgChannels[channel])
					return this.SvgChannels[channel];

				this.SvgChannels[channel] = svg(this.SvgScore.group({ class: "channel", "data-channel": channel }));

				return this.SvgChannels[channel];
			};

			Recorder.prototype.onNoteOn = function (data) {
				//console.log("TimeStampOffset", data.timeStamp * 1000 - Date.now());
				if (this.Recording) {
					if (this.Waiting)
						this.beginRecord();

					var now = this.getTimeStamp(data.timeStamp);

					this.ChannelStatus[data.channel] = this.ChannelStatus[data.channel] || [];
					this.ChannelStatus[data.channel][data.note] = { start: now, velocity: data.velocity };

					if (now < 0)
						console.warn("minus time stamp:", now, this.elapsedTime());
					else
						this.Tracks[0].push({
							//deltaTime: (now - this.LastEventTime) * Recorder.MidiMetaData.secondToTicks,
							time: now,
							type: "channel",
							subtype: "noteOn",
							channel: data.channel,
							noteNumber: data.note,
							velocity: data.velocity
						});
				}
			};

			Recorder.prototype.onNoteOff = function (data) {
				if (this.Recording) {
					if (this.ChannelStatus[data.channel] && this.ChannelStatus[data.channel][data.note]) {
						var status = this.ChannelStatus[data.channel][data.note];
						var now = this.getTimeStamp(data.timeStamp);

						var note = { note: data.note, start: status.start, duration: now - status.start, velocity: status.velocity };

						var channel = this.getChannel(data.channel);
						paintNote(note, channel);

						if (now < 0)
							console.warn("minus time stamp:", now, this.elapsedTime());
						else
							this.Tracks[0].push({
								time: now,
								type: "channel",
								subtype: "noteOff",
								channel: data.channel,
								noteNumber: data.note,
								velocity: 0
							});
					}
				}
			};

			Recorder.prototype.onPedalOn = function (data) {
				if (this.Recording) {
					if (data.channel == 1) {
						if (this.Waiting)
							this.beginRecord();

						if (!this.PedalStatus[data.pedalType]) {
							var now = this.getTimeStamp(data.timeStamp);
							this.PedalStatus[data.pedalType] = { start: now };

							if (now < 0)
								console.warn("minus time stamp:", now, this.elapsedTime());
							else
								this.Tracks[0].push({
									time: now,
									type: "channel",
									subtype: "controller",
									channel: data.channel,
									controllerType: PedalControllerNumber[data.pedalType],
									value: 127
								});
						}
					}
				}
			};

			Recorder.prototype.onPedalOff = function (data) {
				if (this.Recording) {
					if (data.channel == 1) {
						var status = this.PedalStatus[data.pedalType];
						if (status) {
							var now = this.getTimeStamp(data.timeStamp);

							var pedal = { start: status.start, duration: now - status.start, type: data.pedalType };
							if (pedal.duration < 0)
								console.warn("minus pedal data:", pedal);
							else
								paintPedal(pedal, this.SvgPedals);

							this.PedalStatus[data.pedalType] = null;

							if (now < 0)
								console.warn("minus time stamp:", now, this.elapsedTime());
							else
								this.Tracks[0].push({
									time: now,
									type: "channel",
									subtype: "controller",
									channel: data.channel,
									controllerType: PedalControllerNumber[data.pedalType],
									value: 0
								});
						}
					}
				}
			};

			Recorder.prototype.onAnimation = function () {
				$("#playback-time-text").text(toMinutesSeconds(this.elapsedTime()));

				updateScorePosition(this.elapsedTime());
			};


			var Fll = new Follower();

			var Rec = new Recorder();

			var ScoreNotations = null;


			var playMidi = function (data) {
				MIDI.Player.loadFile(data, function () {
					paintScore();

					MIDI.Player.start();
				});
				$("#playback-play").attr("src", "/res/images/pause.png");

				localStorage.SourceData = data;

				$("#playback-save").attr("href", data);
				$("#playback-save").attr("download", localStorage.SourceName);

				MetaData = {};
				updateMetaData();

				Fll.stop();

				MIDI.Player.setAnimation(onMIDIPlayerAnimation);
			};

			var toMinutesSeconds = function (millisec) {
				var minutes = parseInt(millisec / 60000);
				var seconds = parseInt((millisec - minutes * 60000) / 1000);

				return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
			};

			var checkPlugin = function (type) {
				for (var i = 0; i < navigator.plugins.length; ++i) {
					for (var j = 0; j < navigator.plugins[i].length; ++j) {
						if (navigator.plugins[i][j].type == type)
							return navigator.plugins[i];
					}
				}

				return null;
			};

			var refreshMidiInputDevices = function () {
				$("#input-device").empty();

				PitchWheelValue = 0;

				var inputs = MidiIO.getMIDIInputs();
				if (inputs) {
					inputs = inputs.split(",");
					console.log(inputs.length + " MIDI input device(s) detected.");

					for (var i in inputs) {
						$("#input-device").append("<option value='" + i + "'>" + inputs[i] + "</option>");
					}
					$("#input-device").attr("disabled", false);

					var connect = function (id) {
						MidiIO.addConnection(id);

						console.log("Connected input device:", inputs[id]);
					};

					connect($("#input-device").val());

					$("#input-device").unbind("change");
					$("#input-device").change(function () {
						if ($("#input-device").val() >= 0)
							connect($("#input-device").val());
					});
				}
				else {
					$("#input-device").append("<option value='-1'>No MIDI Input Device Detected.</option>");
					$("#input-device").attr("disabled", true);

					console.log("No MIDI input device detected.");
				}
			};

			var svg = function (selector) {
				return new $.svg._wrapperClass($(selector)[0]);
			};

			var velocityToOpacity = function (velocity) {
				return Math.min(Math.max(Math.pow(velocity, 2) / 12100, 0.3), 1);
			};

			RegExp.escape = function (s) {
				return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
			};

			var hasClass = function (elem, cls) {
				if (elem.length)
					return RegExp("(\s|^)" + RegExp.escape(cls) + "(\s|$)", "g").test(elem.attr("class"));

				return false;
			};

			var addClass = function (elem, cls) {
				if (elem.length && !hasClass(elem, cls))
					elem.attr("class", (elem.attr("class") ? elem.attr("class") + " " : "") + cls);
			};

			var removeClass = function (elem, cls) {
				if (elem.length) {
					if (elem.attr("class") == cls)
						elem.attr("class", "");
					else {
						elem.attr("class", elem.attr("class").replace(RegExp("\\s" + RegExp.escape(cls), "g"), ""));
						elem.attr("class", elem.attr("class").replace(RegExp(RegExp.escape(cls) + "\\s", "g"), ""));
					}
				}
			};

			var activeKey = function (key) {
				addClass(key, "active");
			};

			var deactiveKey = function (key) {
				removeClass(key, "active");
			};

			var noteOn = function (data) {
				MIDI.noteOn(data.channel, data.note, data.velocity);

				activeKey($("#keyboard .key[data-note='" + data.note + "']"));

				var bar = $(".note-bar[data-note='" + data.note + "']");
				addClass(bar, "active");
				bar.css("opacity", velocityToOpacity(data.velocity));

				Rec.onNoteOn(data);
				if (!Rec.isRecording())
					Fll.onNoteOn(data.note);
			};

			var noteOff = function (data) {
				MIDI.noteOff(data.channel, data.note);

				deactiveKey($("#keyboard .key[data-note='" + data.note + "']"));

				var bar = $(".note-bar[data-note='" + data.note + "']");
				removeClass(bar, "active");
				bar.css("opacity", "");

				Rec.onNoteOff(data);
				if (!Rec.isRecording())
					Fll.onNoteOff(data.note);
			};

			var noteToX = function (note) {
				var group = Musical.noteGroup(note);
				var pitch = Musical.notePitch(note);
				var pos = PinaoConfig.KeySerials.White.indexOf(pitch);
				if (pos < 0)
					pos = PinaoConfig.KeySerials.BlackPosition[pitch];

				return group * PinaoConfig.KeySerials.White.length + pos - 12;
			};

			var xToNote = function (x) {
				var pos = x + 12;
				var group = Math.floor(pos / 7);
				var pitch = PinaoConfig.KeySerials.White[pos % PinaoConfig.KeySerials.White.length];

				return group * 12 + pitch;
			};

			localStorage.KeyboardRangeLow = localStorage.KeyboardRangeLow || noteToX(PinaoConfig.NoteStart);
			localStorage.KeyboardRangeHigh = localStorage.KeyboardRangeHigh || (noteToX(PinaoConfig.NoteEnd) + 1);

			var ScoreWidth = PinaoConfig.KeyWidth * (noteToX(PinaoConfig.NoteEnd) + 1);


			var resetlocalStorage = function () {
				localStorage.removeItem("KeyboardRangeLow");
				localStorage.removeItem("KeyboardRangeHigh");
				localStorage.removeItem("KeyboardRangeAuto"); 
				localStorage.removeItem("MetaData");
				localStorage.removeItem("KeyMap");
			};

			var updateRangeMask = function () {
				var low = Number(localStorage.KeyboardRangeLow);
				var high = Number(localStorage.KeyboardRangeHigh);

				var keyboardLeft = $("#range-keyboard").offset().left - $("#range-bar").offset().left;
				var left = keyboardLeft + low * PinaoConfig.RangeKeyWidth;
				var right = keyboardLeft + high * PinaoConfig.RangeKeyWidth;

				$("#range-mask-left").css("width", left - 2);
				$("#range-mask-right").css("left", right);
				$("#range-mask-middle").css("left", left);
				$("#range-mask-middle").css("width", right - left - 4);

				$("#keyboard-canvas, #score-canvas").css({
					left: 100 * (-low / (high - low)) + "%",
					width: 100 * ((noteToX(PinaoConfig.NoteEnd) + 1 - noteToX(PinaoConfig.NoteStart)) / (high - low)) + "%"
				});
			};

			var initializeRangeKeyboard = function () {
				var keyboardWhite = svg("#range-keyboard-white");
				var keyboardBlack = svg("#range-keyboard-black");
				for (var note = PinaoConfig.NoteStart; note <= PinaoConfig.NoteEnd; ++note) {
					var pitch = Musical.notePitch(note);
					var x = noteToX(note);
					if (PinaoConfig.KeySerials.White.indexOf(pitch) >= 0) {
						keyboardWhite.rect(x * PinaoConfig.RangeKeyWidth, 0, PinaoConfig.RangeKeyWidth, PinaoConfig.RangeKeyWidth * 3, 0, 0, { class: "key white-key", "data-note": note });
					}
					else {
						keyboardBlack.rect((x - 0.3) * PinaoConfig.RangeKeyWidth, 0, PinaoConfig.RangeKeyWidth * 0.6, PinaoConfig.RangeKeyWidth * 1.9, 0, 0, { class: "key black-key", "data-note": note });
					}
				}

				var keyboardLabels = svg("#range-keyboard-labels");
				keyboardLabels.text((noteToX(PinaoConfig.MiddleC) + 0.5) * PinaoConfig.RangeKeyWidth, PinaoConfig.RangeKeyWidth * 2.8, "C");

				$("#range-keyboard .key").mouseenter(function () {
					activeKey($(this), 60);
				});
				$("#range-keyboard .key").mouseleave(function () {
					deactiveKey($(this));
				});

				$("#range-canvas").css({
					width: $("#range-keyboard-white .key").length * PinaoConfig.RangeKeyWidth + 2,
					height: PinaoConfig.RangeKeyWidth * 3 + 2
				});

				$("#range-bar .mask").mousedown(function () {
					$(this).addClass("hold");

					return false;
				});

				$(window).mouseup(function () {
					$("#range-bar .mask").removeClass("hold");
				});

				$("#range-bar").mousemove(function () {
					var delta = event.webkitMovementX / PinaoConfig.RangeKeyWidth;

					var changed = false;

					var low = Number(localStorage.KeyboardRangeLow);
					var high = Number(localStorage.KeyboardRangeHigh);

					if ($("#range-mask-left").is(".hold")) {
						low += delta;
						low = Math.min(low, high - 7);

						changed = true;
					}

					if ($("#range-mask-right").is(".hold")) {
						high += delta;
						high = Math.max(high, low + 7);

						changed = true;
					}

					if ($("#range-mask-middle").is(".hold")) {
						low += delta;
						low = Math.min(low, high - 7);
						high += delta;
						high = Math.max(high, low + 7);

						changed = true;
					}

					low = Math.max(low, noteToX(PinaoConfig.NoteStart) - 12);
					high = Math.min(high, noteToX(PinaoConfig.NoteEnd) + 13);

					if (changed) {
						localStorage.KeyboardRangeLow = low;
						localStorage.KeyboardRangeHigh = high;

						updateRangeMask();
					}
				});
			};

			var initializeKeyboard = function () {
				$("#keyboard-canvas").attr("viewBox", "0 0 " + ScoreWidth + " 60");
				$("#keyboard-canvas").attr("height", PinaoConfig.KeyHeight + 2);

				$("#score-canvas").attr("viewBox", "0 0 " + ScoreWidth + " " + ($("#score-canvas").height() - 2));

				var keyboardWhite = svg("#keyboard-white");
				var keyboardBlack = svg("#keyboard-black");
				for (var note = PinaoConfig.NoteStart; note <= PinaoConfig.NoteEnd; ++note) {
					var pitch = Musical.notePitch(note);
					var x = noteToX(note);
					if (PinaoConfig.KeySerials.White.indexOf(pitch) >= 0) {
						keyboardWhite.rect(x * PinaoConfig.KeyWidth, 0, PinaoConfig.KeyWidth, PinaoConfig.KeyHeight, 4, 4, { class: "key white-key pitch-" + pitch, "data-note": note });
					}
					else {
						keyboardBlack.rect((x - 0.25) * PinaoConfig.KeyWidth, 0, PinaoConfig.KeyWidth * 0.5, PinaoConfig.KeyHeight * 0.63, 4, 4, { class: "key black-key pitch-" + pitch, "data-note": note });
					}
				}

				var keyboardLabels = svg("#keyboard-labels");
				//keyboardLabels.text((noteToX(PinaoConfig.MiddleC) + 0.5) * PinaoConfig.KeyWidth, PinaoConfig.KeyHeight * 0.9, "C");

				$("#keyboard .key").mousedown(function () {
					noteOn({channel: 0, note: $(this).data("note"), velocity: 100});

					return false;
				});
				$("#keyboard .key").mouseup(function () {
					noteOff({ channel: 0, note: $(this).data("note") });
				});
				$("#keyboard .key").mouseenter(function () {
					if (event.which == 1)
						noteOn({ channel: 0, note: $(this).data("note"), velocity: 100 });
				});
				$("#keyboard .key").mouseleave(function () {
					if (event.which == 1)
						noteOff({ channel: 0, note: $(this).data("note") });
				});
			};

			var initializeScore = function () {
				var background = svg("#score-background");
				var whiteBars = svg("#score-note-bars-white");
				var blackBars = svg("#score-note-bars-black");

				// separators
				for (var x = noteToX(PinaoConfig.NoteStart) + 1; x <= noteToX(PinaoConfig.NoteEnd); ++x) {
					var group = (xToNote(x) % Musical.GroupLen) == 0;
					background.line(x * PinaoConfig.KeyWidth, 0, x * PinaoConfig.KeyWidth, $("#score-canvas").height(), { class: "note-separator" + (group ? " group-separator" : "") });
				}

				// note bars
				for (var note = PinaoConfig.NoteStart; note <= PinaoConfig.NoteEnd; ++note) {
					var pitch = Musical.notePitch(note);
					var x = noteToX(note);
					if (PinaoConfig.KeySerials.White.indexOf(pitch) >= 0)
						whiteBars.rect(x * PinaoConfig.KeyWidth, 0, PinaoConfig.KeyWidth, $("#score-canvas").height(), { class: "note-bar", "data-note": note });
					else
						blackBars.rect((x - 0.25) * PinaoConfig.KeyWidth, 0, PinaoConfig.KeyWidth * 0.5, $("#score-canvas").height(), { class: "note-bar", "data-note": note });
				}
			};

			var parseMidiData = function (data) {
				var channelStatus = [];
				var pedalStatus = {};
				var pedals = {};
				var channels = [];
				var bars = [];
				var time = 0;
				var millisecondsPerBeat = 60000 / 120;
				var beats = 0;
				var tempos = 4;
				var tempoIndex = 0;
				var keyRange = {};
				for (var n = 0; n < data.length; ++n) {
					if (data[n][1] > 0) {
						var deltaBeats = data[n][1] / millisecondsPerBeat;
						for (var b = Math.ceil(beats); b < beats + deltaBeats; ++b) {
							var t = time + (b - beats) * millisecondsPerBeat;
							bars.push({ time: t, index: tempoIndex % tempos });

							++tempoIndex;
						}

						beats += deltaBeats;
					}

					time += data[n][1];

					var event = data[n][0].event;
					switch (event.type) {
						case "channel":
							channelStatus[event.channel] = channelStatus[event.channel] || [];

							switch (event.subtype) {
								case "noteOn":
									note = event.noteNumber - (MIDI.Player.MIDIOffset || 0);
									if (channelStatus[event.channel][note])
										console.warn("unexpected noteOn: ", n, time, event);
									channelStatus[event.channel][note] = { start: time, velocity: event.velocity };

									keyRange.low = Math.min(keyRange.low || note, note);

									break;
								case "noteOff":
									note = event.noteNumber - (MIDI.Player.MIDIOffset || 0);

									channels[event.channel] = channels[event.channel] || [];

									var status = channelStatus[event.channel][note];
									if (!status)
										console.warn("unexpected noteOff: ", n, time, event);
									else {
										channels[event.channel].push({ note: note, start: status.start, duration: time - status.start, velocity: status.velocity });
										channelStatus[event.channel][note] = null;
									}

									keyRange.high = Math.max(keyRange.high || note, note);

									break;
								case "controller":
									switch (event.controllerType) {
										// pedal controllers  
										case 64:
										case 65:
										case 66:
										case 67:
											var pedalType = PedalControllerTypes[event.controllerType];

											pedalStatus[event.channel] = pedalStatus[event.channel] || {};
											pedals[event.channel] = pedals[event.channel] || [];

											var status = pedalStatus[event.channel][pedalType];

											if (event.value > 0) {
												if (!status)
													pedalStatus[event.channel][pedalType] = { start: time, value: event.value };
											}
											else {
												if (status) {
													pedals[event.channel].push({ type: pedalType, start: status.start, duration: time - status.start, value: status.value });

													pedalStatus[event.channel][pedalType] = null;
												}
											}

											break;
									}

									break;
							}

							break;
						case "meta":
							switch (event.subtype) {
								case "setTempo":
									millisecondsPerBeat = event.microsecondsPerBeat / 1000;
									//console.log(beats, 60000 / millisecondsPerBeat);
									//beats = Math.round(beats);

									break;
								case "timeSignature":
									tempos = event.numerator;
									tempoIndex = 0;

									break;
							}

							break;
					}
				}

				var notes = [];
				for (var c in channels) {
					for (var n in channels[c]) {
						notes.push(channels[c][n]);
					}
				}
				notes.sort(function (n1, n2) {
					return n1.start - n2.start;
				});

				for (var i in notes)
					notes[i].index = i;

				return { channels: channels, notes: notes, pedals: pedals, bars: bars, endTime: time, keyRange: keyRange };
			};

			var searchNotation = function (note, options) {
				options = options || {};
				options.begin = options.begin || 0;
				if (options.end === undefined)
					options.end = ScoreNotations.endTime;
				options.backwards = options.backwards || false;

				if (options.referenceIndex === undefined)
					options.referenceIndex = options.backwards ? ScoreNotations.notes.length - 1 : 0;

				var resultIndex = null;
				var resultTime = null;

				for (var i = options.referenceIndex; i >= 0; --i) {
					if (ScoreNotations.notes[i].start < options.begin)
						break;

					if (ScoreNotations.notes[i].start > options.end)
						continue;

					if (ScoreNotations.notes[i].note == note) {
						if ((resultIndex === null) || (options.backwards && ScoreNotations.notes[i].start > resultTime) || (!options.backwards && ScoreNotations.notes[i].start < resultTime)) {
							resultIndex = i;
							resultTime = ScoreNotations.notes[i].start;
						}
					}
				}

				for (var i = options.referenceIndex + 1; i < ScoreNotations.notes.length; ++i) {
					if (ScoreNotations.notes[i].start > options.end)
						break;

					if (ScoreNotations.notes[i].start < options.begin)
						continue;

					if (ScoreNotations.notes[i].note == note) {
						if ((resultIndex === null) || (options.backwards && ScoreNotations.notes[i].start > resultTime) || (!options.backwards && ScoreNotations.notes[i].start < resultTime)) {
							resultIndex = i;
							resultTime = ScoreNotations.notes[i].start;
						}
					}
				}

				return resultIndex;
			};

			var paintNote = function (note, group) {
				var pitch = Musical.notePitch(note.note);
				var x = noteToX(note.note);
				var white = PinaoConfig.KeySerials.White.indexOf(pitch) >= 0;
				var opacity = velocityToOpacity(note.velocity);
				var options = { class: "note pitch-" + pitch, "data-note": note.note/*, "data-pitch": pitch*/, "data-index": note.index, style: "opacity:" + opacity };
				var height = Math.max(note.duration * ScoreTimeScale - 1, 1);
				if (white)
					group.rect(x * PinaoConfig.KeyWidth + 2, note.start * ScoreTimeScale, PinaoConfig.KeyWidth - 4, height, 5, 5, options);
				else
					group.rect((x - 0.25) * PinaoConfig.KeyWidth, note.start * ScoreTimeScale, PinaoConfig.KeyWidth * 0.5, height, options);
			};

			var paintPedal = function (data, group) {
				var options = { class: "pedal pedal-" + data.type, "data-type": data.type };
				group.rect(0, data.start * ScoreTimeScale, 2080, Math.max(data.duration * ScoreTimeScale, 1), 0, 0, options);
			};

			var paintScore = function () {
				ScoreNotations = parseMidiData(MIDI.Player.data);

				$("#score-music").empty();

				var score = svg("#score-music");

				// bars
				var bars = svg(score.group({ id: "score-music-bars" }));
				for (var i in ScoreNotations.bars) {
					bars.line(0, ScoreNotations.bars[i].time * ScoreTimeScale, ScoreWidth, ScoreNotations.bars[i].time * ScoreTimeScale, { class: "beat-bar" + (ScoreNotations.bars[i].index == 0 ? " bar-bar" : "") });
				}
				bars.line(0, ScoreNotations.endTime * ScoreTimeScale, ScoreWidth, ScoreNotations.endTime * ScoreTimeScale, { class: "end-bar" });
				bars.line(0, ScoreNotations.endTime * ScoreTimeScale + 4, ScoreWidth, ScoreNotations.endTime * ScoreTimeScale + 3, { class: "end-bar2" });

				// notes
				for (var c in ScoreNotations.channels) {
					var g = svg(score.group({ class: "channel", "data-channel": c }));
					for (var i = 0; i < ScoreNotations.channels[c].length; ++i) {
						paintNote(ScoreNotations.channels[c][i], g);
					}
				}

				// pedals
				var pedals = svg(score.group({ class: "pedals" }));
				for (var c in ScoreNotations.pedals) {
					for (var i = 0; i < ScoreNotations.pedals[c].length; ++i) {
						paintPedal(ScoreNotations.pedals[c][i], pedals);
					}

					// only paint the first pedal channel
					break;
				}

				if (localStorage.KeyboardRangeAuto) {
					localStorage.KeyboardRangeLow = noteToX(ScoreNotations.keyRange.low);
					localStorage.KeyboardRangeHigh = noteToX(ScoreNotations.keyRange.high) + 1;
					updateRangeMask();
				}
			};

			var updateScorePosition = function (time) {
				if (time === undefined)
					time = MIDI.Player.currentTime || 0;

				$("#score-cursor").attr("y", time * ScoreTimeScale);

				if (Fll.State == Follower.States.Shut) {
					var top = -time * ScoreTimeScale;

					if (Rec.isRecording())
						top += scoreViewportHeight();

					if (top != $("#score-canvas").css("top"))
						$("#score-canvas").css("top", top);
				}
			};

			var updateTempo = function () {
				if (MetaData.Tempo) {
					$("#playback-tempo-numerator").text(MetaData.Tempo.numerator);
					$("#playback-tempo-denominator").text(MetaData.Tempo.denominator);
				}
				else {
					$("#playback-tempo-numerator").empty();
					$("#playback-tempo-denominator").empty();
				}

				localStorage.MetaData = JSON.stringify(MetaData);
			};

			var updateMode = function () {
				if (MetaData.Mode)
					$("#playback-mode").text(Musical.KeySignatureNames[MetaData.Mode.key][MetaData.Mode.scale]);
				else
					$("#playback-mode").empty();

				localStorage.MetaData = JSON.stringify(MetaData);
			};

			var updateSpeed = function () {
				if (MetaData.BeatsPerMinute)
					$("#playback-speed").text("\u2669=" + Math.round(MetaData.BeatsPerMinute));
				else
					$("#playback-speed").empty();

				localStorage.MetaData = JSON.stringify(MetaData);
			};

			var updateMetaData = function () {
				updateTempo();
				updateMode();
				updateSpeed();
			};

			var pickFile = function (file) {
				if (file.type == "audio/mid") {
					var fr = new FileReader();
					fr.onloadend = function (e) {
						console.log("MIDI file loaded:", file.name);

						playMidi(e.currentTarget.result);
					};
					fr.readAsDataURL(file);
					$("#playback-source").text(file.name);

					localStorage.SourceName = file.name;
				}
			};

			var scoreScrollPosition = function () {
				return $("#keyboard-canvas").offset().top + $("#keyboard-canvas").height() - $("#score-canvas").offset().top;
			};

			var scoreViewportHeight = function () {
				return $(window).height() - ($("#keyboard-canvas").offset().top + $("#keyboard-canvas").height());
			};

			var scrollScore = function (delta) {
				MIDI.Player.currentTime = Math.min(Math.max(MIDI.Player.currentTime + delta, 0), MIDI.Player.endTime - 1e-3);
				updateScorePosition();
			};

			var updateLayout = function () {
				//$("#score-canvas").attr("height", $("body").innerHeight() - $("#header").outerHeight() - $("#keyboard-canvas").outerHeight());
				var fullscreen = $(window).width() == window.screen.width && $(window).height() == window.screen.height;
				if (fullscreen)
					$("html").addClass("full-screen");
				else
					$("html").removeClass("full-screen");
			};

			var onMIDIPlayerAnimation = function (data, element) {
				var time = data.now || 0;
				$("#playback-progress-cursor").css("width", (time * 100 / data.end) + "%");
				$("#playback-time-text").text(toMinutesSeconds(time * 1000));

				localStorage.PlaybackProgress = time / data.end;

				if (MIDI.Player.playing) {
					updateScorePosition(time * 1000);
				}

				if (time >= data.end) {
					MIDI.Player.stop();
					$("#playback-play").attr("src", "/res/images/play.png");

					MetaData = {};
					updateMetaData();

					Fll.start();
				}
			};

			$(function () {
				$("body, body *").each(function (i, elem) {
					elem.ondrop = function (e) {
						e.preventDefault();
						return false;
					};
				});

				MIDI.loadPlugin({
					soundfontUrl: "../../soundfont/",
					instrument: "acoustic_grand_piano",
					callback: function () {
						console.log("Web MIDI loaded.");
						$("#loading").fadeOut(900);

						if (localStorage.SourceData) {
							$("#playback-source").text(localStorage.SourceName);
							MIDI.Player.loadFile(localStorage.SourceData, function () {
								MIDI.Player.currentTime = MIDI.Player.endTime * localStorage.PlaybackProgress;

								paintScore();
								updateScorePosition();
							});

							if (localStorage.MetaData) {
								updateMetaData();
							}

							$("#playback-save").attr("href", localStorage.SourceData);
							$("#playback-save").attr("download", localStorage.SourceName);
						}

						$("#playback-play").click(function () {
							if (MIDI.Player.playing) {
								MIDI.Player.pause();

								$("#playback-play").attr("src", "/res/images/play.png");

								Fll.start();

								MIDI.Player.clearAnimation();
							}
							else {
								if (MIDI.Player.currentData) {
									Fll.stop();

									MIDI.Player.resume();

									$("#playback-play").attr("src", "/res/images/pause.png");

									MIDI.Player.setAnimation(onMIDIPlayerAnimation);
								}
							}
						});

						$("#playback-record").click(function () {
							Rec.toggleRecord();
						});

						$("body, body *").each(function (i, elem) {
							elem.ondragover = function (e) {
								$("body").addClass("drag-hover");
								e.preventDefault();
							};
							elem.ondragleave = function () {
								$("body").removeClass("drag-hover");
							};
							elem.ondrop = function (e) {
								$("body").removeClass("drag-hover");

								pickFile(e.dataTransfer.files[0]);

								e.preventDefault();
								return false;
							};
						});

						$("#playback-source").click(function () {
							$("#playback-source-file").click();
						});

						$("#playback-source-file").change(function () {
							if (event.target.files[0])
								pickFile(event.target.files[0]);
						});

						MIDI.Player.addListener(function (data) {
							var key = $("#keyboard .key[data-note='" + data.note + "']");
							var key2 = $("#range-keyboard .key[data-note='" + data.note + "']");

							switch (data.message) {
								case 144:
									activeKey(key);
									activeKey(key2);

									break;
								case 128:
									deactiveKey(key);
									deactiveKey(key2);

									break;
								case "meta":
									switch (data.subtype) {
										case "timeSignature":
											MetaData.Tempo = { denominator: data.denominator, numerator: data.numerator };
											updateTempo();

											break;
										case "keySignature":
											MetaData.Mode = { key: data.key, scale: data.scale };
											updateMode();

											break;
										case "setTempo":
											MetaData.BeatsPerMinute = 60000000 / data.microsecondsPerBeat;
											updateSpeed();

											break;
										case "endOfTrack":
										case "trackName":
										case "instrumentName":
										case "marker":
										case "text":
										case "lyrics":
										case "copyrightNotice":
										case "cuePoint":
										case "midiChannelPrefix":
										case "sequencerSpecific":
										case "unknown":
											if (data.text)
												console.log(data.subtype + ":", data.text);

											break;
										default:
											console.log(data.subtype, data);
									}

									break;
								default:
									//console.log(data.message, data.subtype, data);
							}
						});

						document.onmousewheel = function () {
							if (!MIDI.Player.playing) {
								var beatLength = 60000 / (MetaData.BeatsPerMinute || 120);
								scrollScore(-(event.wheelDelta / 120) * beatLength);

								Fll.State = Follower.States.Idle;
							}

							event.preventDefault();
						};

						$(document).keydown(function () {
							//console.log(event.keyCode);
							switch (event.keyCode) {
								case 32: // Space
									$("#playback-play").click();

									break;
								case 36: // Home
									MIDI.Player.stop();
									$("#playback-play").attr("src", "/res/images/play.png");
									updateScorePosition();

									break;
							}
						});

						$(document).keydown(function () {
							if (KeyMap[event.keyCode]) {
								if (!KeyStatus[event.keyCode]) {	// to avoid auto-repeat
									noteOn({ channel: 0, note: KeyMap[event.keyCode] + (event.shiftKey ? 1 : 0), velocity: 100 });

									KeyStatus[event.keyCode] = true;
								}
							}
						});

						$(document).keyup(function () {
							if (KeyMap[event.keyCode]) {
								noteOff({ channel: 0, note: KeyMap[event.keyCode] + (event.shiftKey ? 1 : 0) });

								KeyStatus[event.keyCode] = false;
							}
						});

						$("#playback-progress").click(function () {
							if (MIDI.Player.data) {
								var progress = (event.x - $("#playback-progress").offset().left) / $("#playback-progress").width();

								var playing = MIDI.Player.playing;

								MIDI.Player.pause();
								MIDI.Player.currentTime = MIDI.Player.endTime * progress;
								if (playing)
									MIDI.Player.resume();

								updateScorePosition();
							}
						});

						$("#playback-progress").mousemove(function () {
							if (MIDI.Player.data) {
								var progress = (event.x - $("#playback-progress").offset().left) / $("#playback-progress").width();
								$("#playback-progress").attr("title", toMinutesSeconds(progress * MIDI.Player.endTime));
							}
						});

						Fll.start();
					}
				});

				initializeRangeKeyboard();

				initializeKeyboard();
				initializeScore();

				updateRangeMask();

				if (!checkPlugin("application/x-klstudio-midi"))
					console.warn("No MIDI NPAPI plugin installed.");
				else {
					console.log("MIDI NPAPI plugin detected.");

					$("#input-device-bar").fadeIn();

					MidiIO = $("#midi-pugin")[0];

					MidiIO.registerCallbackObject({
						printmessage: function (message) {
							//console.log("MIDI in:", message.getTimeStamp(), message.getRawData().toString(16));

							var data = { timeStamp: message.getTimeStamp(), rawData: message.getRawData() };
							if (message.isNoteOnOrOff()) {
								if (message.isNoteOn()) {
									data.type = "NoteOn";
									data.channel = message.getChannel();
									data.note = message.getNoteNumber();
									data.velocity = message.getVelocity();
								}
								else {
									data.type = "NoteOff";
									data.channel = message.getChannel();
									data.note = message.getNoteNumber();
								}
							}
							else if (message.isSustainPedalOn()) {
								data.type = "PedalOn";
								data.pedalType = "Sustain";
								data.channel = message.getChannel();
							}
							else if (message.isSustainPedalOff()) {
								data.type = "PedalOff";
								data.pedalType = "Sustain";
								data.channel = message.getChannel();
							}
							else if (message.isSostenutoPedalOn()) {
								data.type = "PedalOn";
								data.pedalType = "Sostenuto";
								data.channel = message.getChannel();
							}
							else if (message.isSostenutoPedalOff()) {
								data.type = "PedalOff";
								data.pedalType = "Sostenuto";
								data.channel = message.getChannel();
							}
							else if (message.isSoftPedalOn()) {
								data.type = "PedalOn";
								data.pedalType = "Soft";
								data.channel = message.getChannel();
							}
							else if (message.isSoftPedalOff()) {
								data.type = "PedalOff";
								data.pedalType = "Soft";
								data.channel = message.getChannel();
							}
							else if (message.isPitchWheel()) {
								if (!MIDI.Player.playing) {
									data.type = "PitchWheel";
									data.value = message.getPitchWheelValue();
								}
							}

							setTimeout(function () {
								if (!MidiTimeStampOffset)
									MidiTimeStampOffset = Date.now() - data.timeStamp * 1000;

								//console.log("timeStamp", data.timeStamp);
								switch (data.type) {
									case "NoteOn":
										noteOn(data);

										break;
									case "NoteOff":
										noteOff(data);

										break;
									case "PedalOn":
										Rec.onPedalOn(data);

										break;
									case "PedalOff":
										Rec.onPedalOff(data);

										break;
									case "PitchWheel":
										if (!MIDI.Player.playing) {
											PitchWheelValue = (data.value - 0x2000) / 0x2000;
										}

										break;
									default:
										console.log("MIDI message:", data.type);
								}
							}, 0);
						}
					});

					refreshMidiInputDevices();

					$("#input-device-refresh").click(refreshMidiInputDevices);

					$(window).bind("beforeunload", function () {
						MidiIO.cleanup();
						console.log("MIDI plugin cleanup.");
					});
				}

				updateLayout();

				$(window).resize(updateLayout);
			});
		</script>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-20678203-1']);
			_gaq.push(['_trackPageview']);

			(function () {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
	</head>
	<body>
		<div id="header">
			<p>
				<span id="playback">
					<span>
						<input id="playback-play" type="image" src="/res/images/play.png" class="image-button" />
						<input id="playback-record" type="button" class="image-button" />
					</span>
					<span id="playback-time">
						<span id="playback-progress"><span id="playback-progress-cursor"></span></span>
						<span id="playback-time-text"></span>
					</span>
					<span id="playback-source">...</span>
					<input id="playback-source-file" type="file" accept="audio/mid" />
					<a id="playback-save" class="image-button" title="save as MIDI file"></a>
					<span id="playback-metainfo">
						<span id="playback-mode"></span>
						<span id="playback-tempo">
							<span id="playback-tempo-numerator"></span><br /><span id="playback-tempo-denominator"></span>
						</span>
						<span id="playback-speed"></span>
					</span>
				</span>
				<span id="input-device-bar">
					<select id="input-device" disabled="disabled">
					</select>
					<input id="input-device-refresh" class="image-button" type="image" src="/res/images/refresh.png" />
				</span>
			</p>
			<p id="range-controls">
				<span id="range-bar">
					<span id="range-mask-left" class="mask"></span>
					<span id="range-mask-middle" class="mask"></span>
					<span id="range-mask-right" class="mask"></span>
					<svg id="range-canvas">
						<g id="range-keyboard">
							<g id="range-keyboard-white"></g>
							<g id="range-keyboard-black"></g>
							<g id="range-keyboard-labels"></g>
						</g>
					</svg>
				</span>
			</p>
		</div>
		<svg id="keyboard-canvas" preserveAspectRatio="none">
			<g id="keyboard">
				<g id="keyboard-white"></g>
				<g id="keyboard-black"></g>
				<g id="keyboard-labels"></g>
			</g>
		</svg>
		<svg id="score-canvas" preserveAspectRatio="none">
			<defs>
				<linearGradient id="svgdef-gradient-white" x1="0%" y1="0%" x2="0%" y2="100%">
					<stop offset="0%" style="stop-color:white;stop-opacity:1"/>
					<stop offset="4%" style="stop-color:white;stop-opacity:0"/>
				</linearGradient>
				<line id="svgdef-score-cursor" x1="0" y1="0" x2="2080" y2="0"></line>
			</defs>
			<g id="score-background"></g>
			<g id="score-note-bars">
				<g id="score-note-bars-white"></g>
				<g id="score-note-bars-black"></g>
			</g>
			<g id="score-music"></g>
			<g id="score-marks">
				<use id="score-cursor" xlink:href="#svgdef-score-cursor"></use>
				<rect id="score-work-rect" x="0" y="0" width="2080" height="0"></rect>
			</g>
		</svg>
		<div id="loading"></div>
		<embed id="midi-pugin" type="application/x-klstudio-midi" />
		<a id="klstudio" href="/" target="_blank" />
	</body>
</html>
