<html>
	<head>
		<title>Spiral Piano</title>
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<style type="text/css">
			body
			{
				text-align: center;
			}

			body > *
			{
				vertical-align: middle;
			}

			#panel
			{
				width: 800px;
				height: 800px;
			}

			#panel .key
			{
				stroke: white;
				stroke-width: 0;
				filter: url(#filter-grey);
				cursor: pointer;
				opacity: 0.8;
			}

			#panel .key:hover
			{
				filter: url(#filter-middle-saturate);
				opacity: 1;
			}

			#panel .key.active
			{
				filter: url(#filter-brilliancy) !important;
				opacity: 1;
				stroke-width: 2px;
			}

			.pitch-0
			{
				fill: #ff0000;
			}

			.pitch-1
			{
				fill: #ff8600;
			}

			.pitch-2
			{
				fill: #ffb400;
			}

			.pitch-3
			{
				fill: #ffe400;
			}

			.pitch-4
			{
				fill: #eaff00;
			}

			.pitch-5
			{
				fill: #6cff00;
			}

			.pitch-6
			{
				fill: #00ff96;
			}

			.pitch-7
			{
				fill: #00fff6;
			}

			.pitch-8
			{
				fill: #008cff;
			}

			.pitch-9
			{
				fill: #0003ff;
			}

			.pitch-10
			{
				fill: #6e00ff;
			}

			.pitch-11
			{
				fill: #f000ff;
			}

			.key-label
			{
				text-anchor: middle;
			}

			.syllable-label
			{
				text-anchor: middle;
				font-size: 10px;
			}

			.group-1
			{
				filter: url(#filter-brightness-n4);
			}

			.group-2
			{
				filter: url(#filter-brightness-n3);
			}

			.group-3
			{
				filter: url(#filter-brightness-n2);
			}

			.group-4
			{
				filter: url(#filter-brightness-n1);
			}

			.group-6
			{
				filter: url(#filter-brightness-1);
			}

			.group-7
			{
				filter: url(#filter-brightness-2);
			}

			.group-8
			{
				filter: url(#filter-brightness-3);
			}

			.group-9
			{
				filter: url(#filter-brightness-4);
			}

			.region
			{
				stroke: white;
				stroke-width: 1px;
			}

			.region-main
			{
				fill: #ccc;
			}

			.region-deputy
			{
				fill: #777;
			}

			#settings
			{
				display: inline-block;
				text-align: justify;
			}

			#span-keyboard-canvas
			{
				width: 470px;
				height: 60px;
			}

			#span-keyboard .key
			{
				cursor: pointer;
			}

			.white-key
			{
				fill: white;
				stroke: #333;
				stroke-width: 1px;
			}

			.black-key
			{
				fill: black;
			}

			.white-key:hover
			{
				fill: #ccf;
			}

			.black-key:hover
			{
				fill: #00c;
			}

			#span-keyboard-labels text
			{
				text-anchor: middle;
				font-size: 8px;
			}

			#def-vernier
			{
				fill: #ddf;
				stroke: #222;
				stroke-width: 1px;
			}

			#span-verniers
			{
				cursor: pointer;
			}
		</style>
		<script src="../js/jquery.js" type="text/javascript"></script>
		<script src="../js/jquery.svg.js" type="text/javascript"></script>
		<script src="../js/MIDI/AudioDetect.js" type="text/javascript"></script>
		<script src="../js/MIDI/LoadPlugin.js" type="text/javascript"></script>
		<script src="../js/MIDI/Plugin.js" type="text/javascript"></script>
		<script src="../js/MIDI/Player.js" type="text/javascript"></script>
		<script src="../js/MIDI/Window/DOMLoader.XMLHttp.js" type="text/javascript"></script>
		<script src="../js/MIDI/Window/DOMLoader.script.js" type="text/javascript"></script>
		<script src="../js/MIDI/inc/WebMIDIAPI.js" type="text/javascript"></script>
		<script src="../js/MIDI/inc/Base64.js" type="text/javascript"></script>
		<script src="../js/MIDI/inc/base64binary.js" type="text/javascript"></script>
		<script type="text/javascript">
			var Config = {
				GroupLen: 12,
				InnerRadius: 30,
				ScrewPitch: 4,
				Center: { x: 400, y: 400 },
				KeyCount: 88,
				NoteStart: 21,
				NoteEnd: 108,
				MiddleC: 60,
				RegionRadius: 280,
				Mode: {
					Major: {
						MainPitches: { 0: true, 2: true, 4: true, 5: true, 7: true, 9: true, 11: true },
						SyllableNames: ["do", null, "re", null, "mi", "fa", null, "so", null, "la", null, "si"]
					},
					Minor: {
						MainPitches: { 0: true, 2: true, 3: true, 5: true, 7: true, 8: true, 11: true },
						SyllableNames: ["do", null, "re", "mi", null, "fa", null, "so", "la", null, null, "si"]
					}
				},
				KeySerials: {
					White: [0, 2, 4, 5, 7, 9, 11],
					BlackPosition: {
						1: 0.4,
						3: 1.6,
						6: 3.34,
						8: 4.5,
						10: 5.66
					}
				},
				SpanKeyWidth: 9
			};

			var Status = {
				Extends: [],
				KeyPoints: [],
				ModalOffset: 0,
				KeyWidthRatio: 0.7,
				Mode: Config.Mode.Major,
				WideRange: {Start: 55, End: 79}
			};

			var addClass = function(elem, cls){
				elem.attr("class", elem.attr("class") + " " + cls);
			};

			var removeClass = function(elem, cls){
				elem.attr("class", elem.attr("class").replace(RegExp("\\s" + cls, "g"), ""));
			};

			var keyToNote = function(key){
				return Config.NoteEnd - key;
			};

			var noteToKey = function (note) {
				return Config.NoteEnd - note;
			};

			var noteToPitch = function (note) {
				var pitch = note % Config.GroupLen;
				if (pitch < 0)
					pitch += Config.GroupLen;

				return pitch;
			};

			var noteToGroup = function(note){
				return Math.floor(note / Config.GroupLen);
			};

			var getSpanExtends = function (low, high) {
				var exts = [];
				var avg = (low + high) / 2;
				var unit = (low - high) / 2;
				for (var k = 0; k < Config.KeyCount + Config.GroupLen + 1; ++k) {
					var x = (keyToNote(k) - avg) / unit;
					exts[k] = Math.exp(-x * x * x * x / 2) * 70;
				}

				return exts;
			};

			var initializeStatus = function () {
				for (var k = 0; k < Config.KeyCount + Config.GroupLen + 1; ++k) {
					//Status.Extends[k] = 0;
					//Status.Extends[k] = Math.sin((k - 3) * 3 * Math.PI / Config.GroupLen) * 20;
					Status.KeyPoints[k] = Config.InnerRadius + k * Config.ScrewPitch / Config.GroupLen;
				}
				Status.Extends = getSpanExtends(Status.WideRange.Start, Status.WideRange.End);
			};

			var updateKeyPoints = function () {
				for (var k = 0; k < Config.KeyCount + Config.GroupLen + 1; ++k) {
					var exts = 0;
					for (var g = Math.floor(k / Config.GroupLen); g > 0; --g)
						exts += Status.Extends[k - g * Config.GroupLen];

					Status.KeyPoints[k] = Config.InnerRadius + k * Config.ScrewPitch / Config.GroupLen + exts;
				}
			};

			var svg = function (selector) {
				return new $.svg._wrapperClass($(selector)[0]);
			};

			var getOffsetAngles = function (note) {
				var mains = [noteToPitch(note + 1) in Status.Mode.MainPitches, noteToPitch(note) in Status.Mode.MainPitches];
				var offsetAngle = (mains[0] == mains[1]) ? 0.5 : (mains[0] ? 1 - Status.KeyWidthRatio : Status.KeyWidthRatio);

				return offsetAngle;
			};

			var activeKey = function (key, volume) {
				if (volume === undefined)
					volume = 100;

				if (volume > 0)
					MIDI.noteOn(0, key.data("note"), volume);
				addClass(key, "active");
			};

			var deactiveKey = function (key, mute) {
				if (!mute)
					MIDI.noteOff(0, key.data("note"));
				removeClass(key, "active");
			};

			var paintKeys = function () {
				var points = [];
				for (var p = 0; p < Config.KeyCount + Config.GroupLen + 1; ++p) {
					var offsetAngle = getOffsetAngles(keyToNote(p) - Status.ModalOffset);
					var angle = Math.PI * (1.5 - (Status.ModalOffset + p - offsetAngle) * 2 / Config.GroupLen);
					var radius = (Status.KeyPoints[p] + (p > 0 ? Status.KeyPoints[p - 1] : Status.KeyPoints[p])) / 2;

					points[p] = { x: Config.Center.x + Math.cos(angle) * radius, y: Config.Center.y + Math.sin(angle) * radius };
				}

				$("#keys g").empty();
				for (var k = 0; k < Config.KeyCount; ++k) {
					var group = svg("#keys .group-" + noteToGroup(keyToNote(k)));
					var key = group.createPath();

					key.move(points[k].x, points[k].y);
					//key.line(points[k + 1].x, points[k + 1].y);
					key.arc(Status.KeyPoints[k], Status.KeyPoints[k], 0, false, false, points[k + 1].x, points[k + 1].y);
					key.line(points[k + Config.GroupLen + 1].x, points[k + Config.GroupLen + 1].y);
					//key.line(points[k + Config.GroupLen].x, points[k + Config.GroupLen].y);
					key.arc(Status.KeyPoints[k + Config.GroupLen], Status.KeyPoints[k + Config.GroupLen], 0, false, true, points[k + Config.GroupLen].x, points[k + Config.GroupLen].y);
					key.close();

					var shape = group.path(key, { class: "key pitch-" + (keyToNote(k) % Config.GroupLen), "data-note": keyToNote(k) });
				}

				$(".key").mousedown(function () {
					activeKey($(this));

					return false;
				});
				$(".key").mouseup(function () {
					deactiveKey($(this));
				});

				$(".key").mouseenter(function () {
					if (event.which == 1 || $("#settings-touch").attr("checked")) {
						activeKey($(this));
					}
				});
				$(".key").mouseleave(function () {
					if (event.which == 1 || $("#settings-touch").attr("checked")) {
						deactiveKey($(this));
					}
				});

				var getMiddlePoint = function (note) {
					var k = noteToKey(note);
					return { x: (points[k].x + points[k + 1].x + points[k + Config.GroupLen].x + points[k + Config.GroupLen + 1].x) / 4, y: (points[k].y + points[k + 1].y + points[k + Config.GroupLen].y + points[k + Config.GroupLen + 1].y) / 4 };
				};

				$("#keys-labels").empty();
				var keyLabels = svg("#keys-labels");
				var point = getMiddlePoint(Config.MiddleC);
				keyLabels.text(point.x, point.y, "C", { class: "key-label" });
			};

			var paintPanelBackground = function () {
				// labels
				$("#labels").empty();
				var labels = svg("#labels");

				for (var i = 0; i < Config.GroupLen; ++i) {
					if (Status.Mode.SyllableNames[i]) {
						var angle = Math.PI * (1.5 + i * 2 / Config.GroupLen);
						var radius = Config.InnerRadius - 8;
						labels.text(Config.Center.x + Math.cos(angle) * radius, Config.Center.y + 3 + Math.sin(angle) * radius, Status.Mode.SyllableNames[i], { class: "syllable-label" });
					}
				}

				// regions
				var regionPoints = [];
				for (var i = 0; i < Config.GroupLen; ++i) {
					var offsetAngle = getOffsetAngles(i);
					var angle = Math.PI * (1.5 + (i + offsetAngle) * 2 / Config.GroupLen);

					regionPoints[i] = { x: Config.Center.x + Math.cos(angle) * Config.RegionRadius, y: Config.Center.y + Math.sin(angle) * Config.RegionRadius };
				}

				$("#regions").empty();
				var regions = svg("#regions");
				for (var i = 0; i < Config.GroupLen; ++i) {
					var nextIndex = (i > 0) ? i - 1 : Config.GroupLen - 1;
					var region = regions.createPath();
					region.move(Config.Center.x, Config.Center.y);
					region.line(regionPoints[i].x, regionPoints[i].y);
					region.arc(Config.RegionRadius, Config.RegionRadius, 0, false, false, regionPoints[nextIndex].x, regionPoints[nextIndex].y);
					region.close();

					regions.path(region, { class: "region region-" + i + " region-" + (noteToPitch(i + Status.ModalOffset) in Status.Mode.MainPitches ? "main" : "deputy") });
				}
			};

			var initializeSpanKeyboard = function () {
				var noteToX = function (note) {
					var group = noteToGroup(note);
					var pitch = noteToPitch(note);
					var pos = Config.KeySerials.White.indexOf(pitch);
					if (pos < 0)
						pos = Config.KeySerials.BlackPosition[pitch];

					return group * Config.KeySerials.White.length + pos - 12;
				};

				var xToNote = function (x) {
					var pos = Math.floor(x / Config.SpanKeyWidth) + 12;
					var group = Math.floor(pos / 7);
					var pitch = Config.KeySerials.White[pos % 7];

					return group * 12 + pitch;
				};

				var keyboardWhite = svg("#span-keyboard-white");
				var keyboardBlack = svg("#span-keyboard-black");
				for (var note = Config.NoteStart; note <= Config.NoteEnd; ++note) {
					var pitch = noteToPitch(note);
					var x = noteToX(note);
					if (Config.KeySerials.White.indexOf(pitch) >= 0) {
						keyboardWhite.rect(x * Config.SpanKeyWidth, 0, Config.SpanKeyWidth, Config.SpanKeyWidth * 4, 0, 0, { class: "key white-key", "data-note": note });
					}
					else {
						keyboardBlack.rect((x + 0.1) * Config.SpanKeyWidth, 0, Config.SpanKeyWidth * 0.8, Config.SpanKeyWidth * 2.4, 0, 0, { class: "key black-key", "data-note": note });
					}
				}

				var keyboardLabels = svg("#span-keyboard-labels");
				keyboardLabels.text((noteToX(Config.MiddleC) + 0.5) * Config.SpanKeyWidth, Config.SpanKeyWidth * 3.5, "C");

				$("#span-keyboard .key").mouseenter(function () {
					activeKey($(this), 60);

					activeKey($("#panel .key[data-note='" + $(this).data("note") + "']"), 0);
				});
				$("#span-keyboard .key").mouseleave(function () {
					deactiveKey($(this));

					deactiveKey($("#panel .key[data-note='" + $(this).data("note") + "']"), true);
				});

				$("#span-verniers-start").attr("x", noteToX(Status.WideRange.Start) * Config.SpanKeyWidth);
				$("#span-verniers-end").attr("x", noteToX(Status.WideRange.End) * Config.SpanKeyWidth);

				$(".vernier").mousedown(function () {
					addClass($(this), "hold");

					return false;
				});

				$("#span-keyboard-canvas, #span-verniers").mouseup(function () {
					removeClass($("#span-verniers-start"), "hold");
					removeClass($("#span-verniers-end"), "hold");
				});

				var onVernierMove = function () {
					var x = event.pageX - $("#span-keyboard-canvas").offset().left;
					var changed = false;

					if ($("#span-verniers-start").is(".hold")) {
						Status.WideRange.Start = Math.min(xToNote(x), Status.WideRange.End - 5);
						$("#span-verniers-start").attr("x", noteToX(Status.WideRange.Start) * Config.SpanKeyWidth);

						changed = true;
					}

					if ($("#span-verniers-end").is(".hold")) {
						Status.WideRange.End = Math.max(xToNote(x), Status.WideRange.Start + 5);
						$("#span-verniers-end").attr("x", noteToX(Status.WideRange.End) * Config.SpanKeyWidth);

						changed = true;
					}

					if (changed) {
						Status.Extends = getSpanExtends(Status.WideRange.Start, Status.WideRange.End);
						updateKeyPoints();
						paintKeys();
					}
				};

				$("#span-keyboard-canvas, #span-verniers").mousemove(onVernierMove);
			};

			$(function () {
				MIDI.loadPlugin({
					soundfontUrl: "../soundfont/",
					instrument: "acoustic_grand_piano",
					callback: function () { console.log("MIDI loaded."); }
				});

				initializeStatus();

				paintPanelBackground();

				updateKeyPoints();
				paintKeys();

				initializeSpanKeyboard();

				$("#settings-mode").change(function () {
					Status.ModalOffset = Number($("#settings-mode").val());

					paintPanelBackground();
					paintKeys();
				});
			});
		</script>
	</head>
	<body>
		<svg id="panel">
			<defs>
				<filter id="filter-brilliancy">
					<feColorMatrix type="saturate" values="1.2"/>
				</filter>
				<filter id="filter-middle-saturate">
					<feColorMatrix type="saturate" values="0.7"/>
				</filter>
				<filter id="filter-grey">
					<feColorMatrix type="saturate" values="0.4"/>
				</filter>
				<filter id="filter-brightness-n4">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="-0.4" slope="1"/>
						<feFuncG type="linear" intercept="-0.4" slope="1"/>
						<feFuncB type="linear" intercept="-0.4" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-n3">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="-0.3" slope="1"/>
						<feFuncG type="linear" intercept="-0.3" slope="1"/>
						<feFuncB type="linear" intercept="-0.3" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-n2">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="-0.2" slope="1"/>
						<feFuncG type="linear" intercept="-0.2" slope="1"/>
						<feFuncB type="linear" intercept="-0.2" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-n1">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="-0.1" slope="1"/>
						<feFuncG type="linear" intercept="-0.1" slope="1"/>
						<feFuncB type="linear" intercept="-0.1" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-1">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="0.1" slope="1"/>
						<feFuncG type="linear" intercept="0.1" slope="1"/>
						<feFuncB type="linear" intercept="0.1" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-2">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="0.2" slope="1"/>
						<feFuncG type="linear" intercept="0.2" slope="1"/>
						<feFuncB type="linear" intercept="0.2" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-3">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="0.3" slope="1"/>
						<feFuncG type="linear" intercept="0.3" slope="1"/>
						<feFuncB type="linear" intercept="0.3" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-4">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="0.4" slope="1"/>
						<feFuncG type="linear" intercept="0.4" slope="1"/>
						<feFuncB type="linear" intercept="0.4" slope="1"/>
					</feComponentTransfer>
				</filter>
				<filter id="filter-brightness-5">
					<feComponentTransfer>
						<feFuncR type="linear" intercept="0.4" slope="1"/>
						<feFuncG type="linear" intercept="0.4" slope="1"/>
						<feFuncB type="linear" intercept="0.4" slope="1"/>
					</feComponentTransfer>
				</filter>
			</defs>
			<g id="regions"></g>
			<g id="labels"></g>
			<g id="keys">
				<g id="keys-labels"></g>
				<g class="group-1"></g>
				<g class="group-2"></g>
				<g class="group-3"></g>
				<g class="group-4"></g>
				<g class="group-5"></g>
				<g class="group-6"></g>
				<g class="group-7"></g>
				<g class="group-8"></g>
				<g class="group-9"></g>
			</g>
		</svg>
		<div id="settings">
			<p>
				<svg id="span-keyboard-canvas">
					<defs>
						<g id="def-vernier">
							<path d="M0,0 L-16,0 C0,0 -10,-16 0,-16z"></path>
						</g>
						<use id="def-vernier-mirror" xlink:href="#def-vernier" transform="scale(-1, 1)"></use>
					</defs>
					<g id="span-keyboard">
						<g id="span-keyboard-white"></g>
						<g id="span-keyboard-black"></g>
						<g id="span-keyboard-labels"></g>
					</g>
					<g id="span-verniers">
						<use id="span-verniers-start" class="vernier" xlink:href="#def-vernier" y="60"></use>
						<use id="span-verniers-end" class="vernier" xlink:href="#def-vernier-mirror" y="60"></use>
					</g>
				</svg>
			</p>
			<p>
				<input id="settings-touch" type="checkbox" /> Touch
			</p>
			<p>
				Mode: <select id="settings-mode">
					<option value="-5">G</option>
					<option value="-4">G# / Ab</option>
					<option value="-3">A</option>
					<option value="-2">A# / Bb</option>
					<option value="-1">B</option>
					<option value="0" selected="selected">C</option>
					<option value="1">C# / Db</option>
					<option value="2">D</option>
					<option value="3">D# / Eb</option>
					<option value="4">E</option>
					<option value="5">F</option>
					<option value="6">F# / Gb</option>
				</select>
			</p>
		</div>
	</body>
</html>
