var A=Object.defineProperty;var S=(s,t,n)=>t in s?A(s,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[t]=n;var p=(s,t,n)=>S(s,typeof t!="symbol"?t+"":t,n);const I=([s,t,n,i],[r,o,u,c])=>[c*s+r*i+o*n-u*t,c*t-r*n+o*i+u*s,c*n+r*t-o*s+u*i,c*i-r*s-o*t-u*n];class e{constructor(t,n){p(this,"unit");p(this,"exponent");this.unit=t,this.exponent=n}toString(){let t;switch(this.exponent){case 0:return"";case-1:t="'";break;case 1:t="";break;default:t=this.exponent.toString();break}return"ijk"[this.unit]+t}toQuaternion(){const t=[0,0,0];t[this.unit]=1;const n=-Math.PI*.5*this.exponent,i=Math.sin(n/2),r=Math.cos(n/2);return[t[0]*i,t[1]*i,t[2]*i,r]}normalized(){let t=this.exponent%4;switch(t){case 3:t=-1;break;case-3:t=1;break;case-2:t=2;break}return t===this.exponent?this:new e(this.unit,t)}inverted(){return new e(this.unit,-this.exponent)}mul(t){return console.assert(this.unit===t.unit),new e(this.unit,this.exponent+t.exponent)}static supplementaryUnit(t,n){return 3-t.unit-n.unit}static sqauredReduce(t,n){return t.exponent===2&&n.exponent===2?[new e(this.supplementaryUnit(t,n),2)]:n.exponent===2&&n.unit===2&&t.unit===0?[t.inverted(),_]:null}static exchangeReduce(t,n){if(t.unit===0||t.unit===n.unit)return null;const i=(n.unit-t.unit+3)%3===1,r=i?1:2,o=t.exponent*n.exponent*(i?1:-1),u=e.supplementaryUnit(t,n),c=new e(u,o),k=[t,n,c].reduce((N,O)=>(N[O.unit]=O.exponent,N),[]);return[new e(0,k[0]),new e(r,k[r])]}}class g{constructor(t=[]){p(this,"items");this.items=t}toString(){return this.items.length?this.items.map(t=>t.toString()).join(""):"1"}toQuaternion(){return this.items.reduce((t,n)=>I(t,n.toQuaternion()),[0,0,0,1])}normalize(){this.items=this.items.map(t=>t.normalized());for(let t=0;t<this.items.length;++t)if(this.items[t].exponent===2){const n=new e(this.items[t].unit,1);this.items.splice(t,1,n,n),++t}for(;;){let t=null;for(let n=1;n<this.items.length;++n)if(t=e.exchangeReduce(this.items[n-1],this.items[n]),t){this.items.splice(n-1,2,...t);break}if(!t)break}for(let t=1;t<this.items.length;++t)this.items[t].unit===this.items[t-1].unit&&(this.items.splice(t-1,2,this.items[t-1].mul(this.items[t])),--t);if(this.items=this.items.map(t=>t.normalized()).filter(t=>t.exponent!==0),this.items.length>=2){const t=e.sqauredReduce(...this.items);t&&this.items.splice(0,2,...t)}return this}mul(t){return new g(this.items.concat(t.items))}}const h=new e(0,1),a=new e(0,-1),l=new e(0,2),x=new e(1,1),m=new e(1,-1),_=new e(1,2),f=new e(2,1),w=new e(2,-1),M=new e(2,2),d=[[],[h],[x],[f],[a],[m],[w],[l],[_],[M],[h,x],[a,x],[l,x],[h,m],[a,m],[l,m],[h,f],[a,f],[l,f],[h,w],[a,w],[l,w],[h,_],[a,_]].map(s=>new g(s)),R=d.map(s=>s.toString()),T=d.map(s=>d.map(t=>R.indexOf(s.mul(t).normalize().toString()))),E=T.map(s=>Array(s.length).fill(null).map((t,n)=>s.indexOf(n)));export{E as D,h as I,x as J,f as K,T as M,d as N,a,m as b,w as c,l as d,_ as e,M as f};
